{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Procesy a vl\u00e1kna (multithreding) \u00b6 Android develoment Pri spusten\u00ed aplik\u00e1cie Android OS spust\u00ed nov\u00fd proces (Linux) s jedn\u00fdm vl\u00e1knom. \u0160tandardne v\u0161etky komponenty aplik\u00e1cie be\u017eia na rovnakom procese v tzv. \"hlavnom\" vl\u00e1kne v Android-e tie\u017e naz\u00fdvan\u00e9 UI vl\u00e1kno. Toto \u0161tandardn\u00e9 spr\u00e1vanie sa d\u00e1 ovplyvni\u0165 v manifeste AndroidManifest.xml a takisto v ka\u017edom procese je mo\u017en\u00e9 vytvori\u0165 \u010fal\u0161ie vl\u00e1kna. Procesy \u00b6 V predvolenom nastaven\u00ed s\u00fa v\u0161etky komponenty tej istej aplik\u00e1cie spusten\u00e9 v rovnakom procese a v\u00e4\u010d\u0161ina aplik\u00e1ci\u00ed by to nemala meni\u0165. Ak v\u0161ak je potrebn\u00e9 zmeni\u0165 zaradenie do ktor\u00e9ho procesu dan\u00e1 komponenta patr\u00ed, m\u00f4\u017eeme tak spravi\u0165 v s\u00fabore AndroidManifest.xml : Komponenty ako <activity>, <service>, <receiver>, <provider> podporuj\u00fa atrib\u00fat android:process , pomocou ktor\u00e9ho m\u00f4\u017eeme upravi\u0165 v akom procese maj\u00fa komponenty be\u017ea\u0165 (vlastn\u00fd proces, zdielan\u00fd proces). Komponent <application> umo\u017e\u0148uje nastavi\u0165 atrib\u00fat android:process , ktor\u00fdm sa nastav\u00ed predvolen\u00e1 hodnota. V pr\u00edpadoch kedy Android potrebuje uvolni\u0165 HW prostriedky alebo \u0161etri\u0165 energiou sa m\u00f4\u017ee rozhodn\u00fa\u0165 ne\u010dinn\u00e9 procesy zastavi\u0165. Ak niektor\u00e9 zastavan\u00e9 komponenty maj\u00fa op\u00e4tovne pridelen\u00fa pr\u00e1cu tak s\u00fa znova spusten\u00e9 v procese. Pre spr\u00e1vne fungovanie aplik\u00e1cie je potrebn\u00e9 spr\u00e1vne implementova\u0165 \u017eivotn\u00fd cyklus procesu (predch\u00e1dzaj\u00face predn\u00e1\u0161ky a cvi\u010denia). Vl\u00e1kna \u00b6 Pri spusten\u00ed aplik\u00e1cie syst\u00e9m vytvor\u00ed pre aplik\u00e1ciu vl\u00e1kno, ktor\u00e9 sa naz\u00fdva hlavn\u00e9 vl\u00e1kno alebo niekedy tie\u017e \"UI\" vl\u00e1kno. Toto vl\u00e1kno je d\u00f4le\u017eit\u00e9, preto\u017ee m\u00e1 na starosti odosielanie udalost\u00ed na pr\u00edslu\u0161n\u00e9 komponenty u\u017e\u00edvate\u013esk\u00e9ho rozhrania. Dan\u00e9 vl\u00e1kno je zodpovedn\u00e9 aj za samotn\u00e9 vykres\u013eovanie UI. Za zvl\u00e1\u0161tnych okolnost\u00ed v\u0161ak hlavn\u00e9 vl\u00e1kno aplik\u00e1cie nemus\u00ed by\u0165 toto\u017en\u00e9 s UI vl\u00e1knom. Ako je v\u0161ak uveden\u00e9 v dokument\u00e1cii, rozdiel je d\u00f4le\u017eit\u00fd iba v s\u00favislosti s niektor\u00fdmi syst\u00e9mov\u00fdmi aplik\u00e1ciami (aplik\u00e1ciami, ktor\u00e9 s\u00fa spusten\u00e9 ako s\u00fa\u010das\u0165 OS). \u010eal\u0161ie inform\u00e1cie sa nach\u00e1dzaj\u00fa v t\u00e9me Annotations Thread . Hlavn\u00e9 \"UI\" vl\u00e1kno \u00b6 Hlavn\u00e9 vl\u00e1kno m\u00e1 jednoduch\u00fd dizajn: Jeho jedinou \u00falohou je \u010daka\u0165 na pridelenie \u00falohy z pracovnej fronty a n\u00e1sledne jej vykonanie. Tieto \u00falohy prich\u00e1dzaj\u00fa z r\u00f4znych zdrojov ako napr. udalosti sp\u00e4t\u00e9 zo \u017eivotn\u00fdm cyklom aplik\u00e1cie, udalosti od u\u017e\u00edvate\u013esk\u00e9ho rozhrania, udalosti od ostatn\u00fdch aplik\u00e1ci\u00ed. Pridelen\u00e1 \u00faloha sa spracov\u00e1va v r\u00f4znych obslu\u017en\u00fdch met\u00f3dach ako napr.: v obslu\u017en\u00fdch met\u00f3dach \u017eivotn\u00e9ho cyklu onStart(),onResume(),onRestart(), onCreate(),onPause(),onStop(), onDestroy() , at\u010f v obslu\u017en\u00fdch met\u00f3dach u\u017e\u00edvate\u013esk\u00e9ho rozhrania onClick(), onKeyDown() , at\u010f Uk\u00e1\u017eka \u010dinnosti hlavn\u00e9ho vl\u00e1kna Hlavn\u00e9 vl\u00e1kno m\u00e1 tie\u017e za \u00falohu v pravideln\u00fdch intervaloch vykres\u013eova\u0165 u\u017e\u00edvate\u013esk\u00e9 rozhranie (ka\u017ed\u00fdch 16ms \u010do je 60Hz). Ak hlavn\u00e9 vl\u00e1kno vykon\u00e1va nejak\u00fa \u010dasovo n\u00e1ro\u010dn\u00fa \u00falohou alebo je zahlten\u00e9 ve\u013ek\u00fdm mno\u017estvom udalost\u00ed na spracovanie tak u\u017e\u00edvate\u013esk\u00e9 rozhranie m\u00f4\u017ee by\u0165 spomalen\u00e9. Ak hlavn\u00e9 vl\u00e1kno sa zablokuje pribli\u017ene na p\u00e4\u0165 sek\u00fand, syst\u00e9m zobraz\u00ed dial\u00f3gov\u00e9 okno: aplik\u00e1ciu neodpoved\u00e1 (ANR), ktor\u00e9 umo\u017e\u0148uje pou\u017e\u00edvate\u013eovi zatvori\u0165 aplik\u00e1ciu. Norm\u00e1lna \u010dinnos\u0165 hlavn\u00e9ho vl\u00e1kna Zablokovanie hlavn\u00e9ho vl\u00e1kna Presunutie n\u00e1ro\u010denej oper\u00e1cie na pracovn\u00e9 vl\u00e1kno Ak hlavn\u00e9 vl\u00e1kno sa zablokuje pribli\u017ene na p\u00e4\u0165 sek\u00fand, syst\u00e9m zobraz\u00ed dial\u00f3gov\u00e9 okno Najv\u00e4\u010d\u0161\u00edm d\u00f4vodom na zav\u00e1dzanie vl\u00e1kien do aplik\u00e1cie je presun v\u00fdpo\u010dtovo n\u00e1ro\u010dn\u00fdch \u00faloh z hlavn\u00e9ho vl\u00e1kna preto, aby neovplyv\u0148ovali plynulos\u0165 vykres\u013eovania a r\u00fdchlos\u0165 reakcie na vstup pou\u017e\u00edvate\u013ea. Vl\u00e1kna, ktor\u00e9 odbreme\u0148uj\u00fa hlavn\u00e9 vl\u00e1kno, budeme naz\u00fdva\u0165 pracovn\u00fdmi vl\u00e1knami . Pr\u00edstup k met\u00f3dam u\u017e\u00edvate\u013esk\u00e9ho rozhrania nie je s poh\u013eadu viacvl\u00e1knovej aplik\u00e1cie bezpe\u010dn\u00fd a teda priamy pr\u00edstup k t\u00fdmto met\u00f3da z in\u00e9ho vl\u00e1kna ako je hlavn\u00e9 vl\u00e1kno je zak\u00e1zan\u00fd. StrictMode \u2013 n\u00e1stroj na detekciu omylov v k\u00f3de, ktor\u00e9 m\u00f4\u017eu sp\u00f4sobova\u0165 ANR hl\u00e1\u0161ky StrictMode je n\u00e1stroj pre v\u00fdvoj\u00e1rov, ktor\u00fd m\u00e1 za \u00falohu upozor\u0148ova\u0165 na chyby z nepozornosti aby ste ich mohli opravi\u0165. StrictMode sa naj\u010dastej\u0161ie pou\u017e\u00edva na odhalenie n\u00e1hodn\u00e9ho pr\u00edstupu na disk alebo do siete v hlavnom vl\u00e1kne aplik\u00e1cie, kde sa \u0161tandardne vykon\u00e1vaj\u00fa iba oper\u00e1cie t\u00fdkaj\u00face sa u\u017evatelsk\u00e9 rozhrania. Udr\u017eiavanie diskov\u00fdch a sie\u0165ov\u00fdch oper\u00e1ci\u00ed mimo hlavn\u00e9ho vl\u00e1kna m\u00e1 pozit\u00edvny vplyv na plynulos\u0165 a r\u00fdchlu odozvu aplik\u00e1cie. public void onCreate () { if ( DEVELOPER_MODE ) { StrictMode . setThreadPolicy ( new ThreadPolicy . Builder () . detectDiskReads () . detectDiskWrites () . detectNetwork () // or .detectAll () pre v\u0161etky zistite\u013en\u00e9 probl\u00e9my . penaltyLog () . build () ; StrictMode . setVmPolicy ( new VmPolicy . Builder () . detectLeakedSqlLiteObjects () . detectLeakedClosableObjects () . penaltyLog () . penaltyDeath () . build ()); } super . onCreate (); } Vylep\u0161ite kontrolu k\u00f3du pomocou anot\u00e1ci\u00ed Android podporuje mno\u017estvo anot\u00e1ci\u00ed prostredn\u00edctvom Kni\u017enice podpory anot\u00e1ci\u00ed . Kni\u017enicu m\u00f4\u017eete z\u00edska\u0165 prostredn\u00edctvom android.support.annotation bal\u00edka. Ak chcete do svojho projektu prida\u0165 kni\u017enicu na podporu anot\u00e1ci\u00ed, do dependencies bloku v s\u00fabore build.gradle pridajte nasleduj\u00faci riadok a zosynchronizujte projekt: dependencies { implementation 'com.android.support:support-annotations:28.0.0' } Ak chcete spusti\u0165 kontrolu k\u00f3du z Android Studia, ktor\u00e1 zah\u0155\u0148a overenie anot\u00e1ci\u00ed a automatick\u00fa kontrolu pomocou programu Lint, na paneli s ponukami vyberte Analyzova\u0165 > Skontrolova\u0165 k\u00f3d ( Analyze > Inspect Code ). Upozor\u0148ujeme, \u017ee hoci konflikty anot\u00e1ci\u00ed generuj\u00fa upozornenia, tieto upozornenia nebr\u00e1nia kompil\u00e1cii aplik\u00e1cie. Naj\u010dastej\u0161ie pou\u017e\u00edvan\u00e9 anot\u00e1cie anot\u00e1cii: Kotrola null hodn\u00f4t: @Nullable @NonNull Anot\u00e1cie zdrojov: napr. @DrawableRes, @DimenRes, @ColorResa @InterpolatorRes, @StringRes Anot\u00e1cie na obmedzenie vstupn\u00fdch hodn\u00f4t napr. @IntRange, @FloatRangea, @Size Anot\u00e1cie k povoleniam napr. @RequiresPermission Anot\u00e1cie na kontrolu, \u010di sa met\u00f3da vol\u00e1 z konkr\u00e9tneho typu vl\u00e1kna @MainThread @UiThread @WorkerThread @BinderThread @AnyThread Ostatn\u00e9 si mo\u017eete dohlada\u0165 tu Ako u\u017e bolo p\u00edsan\u00e9 v predch\u00e1dzaj\u00facich odsekoch na hlavnom vl\u00e1kne sa nesm\u00fa vykon\u00e1va\u0165 \u010dasovo n\u00e1ro\u010dn\u00e9 \u00falohy, ktor\u00e9 by mohli toto vl\u00e1kno zablokova\u0165. V\u0161etky n\u00e1ro\u010dnej\u0161ie \u00falohy by sa mali vykon\u00e1va\u0165 na pracovn\u00fdch vl\u00e1knach, ktor\u00e9 s\u00fa riaden\u00e9 z hlavn\u00e9ho vl\u00e1kna. Treba pripomen\u00fa\u0165, \u017ee pr\u00e1ca z u\u017e\u00edvate\u013esk\u00fdm rozhran\u00edm je dovolen\u00e1 iba z hlavn\u00e9ho vl\u00e1kna. Na vyrie\u0161enie probl\u00e9mu s pr\u00edstupom k u\u017e\u00edvate\u013esk\u00e9mu rozhranie mimo hlavn\u00e9ho vl\u00e1kna Android poskytuje viacero mo\u017enost\u00ed: Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) Pr\u00edklad aktualiz\u00e1cie u\u017e\u00e1vate\u013esk\u00e9ho rozhrania z pracovn\u00e9ho vl\u00e1kna pomocu odoslania Runnable objektu public void onClick ( View v ) { new Thread ( new Runnable () { public void run () { // potenci\u00e1lne \u010dasovo n\u00e1ro\u010dn\u00e1 \u00faloha final Bitmap bitmap = processBitMap ( \"image.png\" ); imageView . post ( new Runnable () { public void run () { imageView . setImageBitmap ( bitmap ); } }); } }). start (); } Oper\u00e1cia \u00fapravy obr\u00e1zku sa vykon\u00e1va zo samostatn\u00e9ho vl\u00e1kna, zatia\u013e \u010do s objektom ImageView sa v\u017edy manipuluje z hlavn\u00e9ho vl\u00e1kna (UI). ``` Z rast\u00facou zlo\u017eitos\u0165ou aplik\u00e1cie m\u00f4\u017ee priame pou\u017e\u00edvanie vl\u00e1ken by\u0165 kompilovan\u00e9 a nepreh\u013eadn\u00e9. Android poskytuje efekt\u00edvnej\u0161ie sp\u00f4soby ako pracova\u0165 s \u00falohami na pozad\u00ed: Vykonanie n\u00e1ro\u010dn\u00fdch v\u00fdpo\u010dtov na pozad\u00ed za pomoci service komponenty syst\u00e9mu a vyu\u017eitia notifik\u00e1cii ( notifications ) pre informovanie pou\u017e\u00edvate\u013ea. IntentService, Foreground service Vykonanie n\u00e1ro\u010dn\u00fdch v\u00fdpo\u010dtov pomocou vl\u00e1kna . Spolupr\u00e1ca a komunik\u00e1cia medzi vl\u00e1knami je mo\u017en\u00e1 pomocou obslu\u017en\u00fdch Handler objektov a posielania Runnable objektov. AsyncTask, AsyncTaskLoader, HandlerThread, ThreadPool \u0160pecializovan\u00e9 kni\u017enice WorkManager, AlarmManager, DownloadManager Nastavenie priority \u00b6 Priorita, ktor\u00fa dostan\u00fa vl\u00e1kna v aplik\u00e1ci\u00ed, z\u00e1vis\u00ed \u010diasto\u010dne od toho, kde sa aplik\u00e1cia nach\u00e1dza v \u017eivotnom cykle aplik\u00e1cie. Pri vytv\u00e1ran\u00ed a spr\u00e1ve vl\u00e1kien je d\u00f4le\u017eit\u00e9 nastavi\u0165 ich prioritu. Ak je nastaven\u00e1 pr\u00edli\u0161 vysoko, va\u0161e vl\u00e1kno m\u00f4\u017ee preru\u0161i\u0165 vl\u00e1kno UI a RenderThread, \u010do m\u00f4\u017ee sp\u00f4sobi\u0165, \u017ee aplik\u00e1cia vynech\u00e1 r\u00e1mce pri vykres\u013eovan\u00ed UI. Opa\u010dn\u00fd extr\u00e9m je ak je nastaven\u00e1 pr\u00edli\u0161 n\u00edzka priorita, \u010do m\u00f4\u017ee sp\u00f4sobi\u0165, \u017ee asynchr\u00f3nne \u00falohy (napr\u00edklad na\u010d\u00edtanie obr\u00e1zkov) bud\u00fa pr\u00edli\u0161 spomalen\u00e9. V\u017edy, ke\u010f je vytvoren\u00e9 nov\u00e9 vl\u00e1kno je vhodn\u00e9 zavola\u0165 setThreadPriority() a nastavi\u0165 vl\u00e1knu vhodn\u00fa prioritu tak aby pl\u00e1nova\u010d vybalancoval vyta\u017eenie CPU. Pre jednoduch\u0161ie zvolenie spr\u00e1vnej priority existuj\u00fa pomocn\u00e9 kon\u0161tanty cez ktor\u00e9 m\u00f4\u017eete zvoli\u0165 spr\u00e1vnu prioritu vi\u010f. tabu\u013eka ni\u017e\u0161ie. Napr\u00edklad THREAD_PRIORITY_DEFAULT predstavuje predvolen\u00fa hodnotu pre vl\u00e1kno. Aplik\u00e1cia by mala nastavi\u0165 prioritu THREAD_PRIORITY_BACKGROUND pre vl\u00e1kna, ktor\u00e9 vykon\u00e1vaj\u00fa menej naliehav\u00fa pr\u00e1cu. Vl\u00e1kna, ktor\u00e9 s\u00fa v aplik\u00e1cii, ktor\u00e1 je v popred\u00ed zvy\u010dajne z\u00edskavaj\u00fa asi 95% procesn\u00e9ho \u010dasu , zatia\u013e \u010do vl\u00e1kna v aplik\u00e1cii v pozad\u00ed z\u00edskavaj\u00fa iba zhruba 5%. V predvolenom nastaven\u00ed syst\u00e9m nastav\u00ed prioritu vl\u00e1kna na rovnak\u00fa prioritu a \u010dlenstvo v skupine ako vl\u00e1kno, ktor\u00e9 vytvorilo nov\u00e9 vl\u00e1kno. Kon\u0161tanta int THREAD_PRIORITY_AUDIO Standard priority of audio threads. int THREAD_PRIORITY_BACKGROUND Standard priority background threads. int THREAD_PRIORITY_DEFAULT Standard priority of application threads. int THREAD_PRIORITY_DISPLAY Standard priority of system display threads, involved in updating the user interface. int THREAD_PRIORITY_FOREGROUND Standard priority of threads that are currently running a user interface that the user is interacting with. int THREAD_PRIORITY_LESS_FAVORABLE Minimum increment to make a priority less favorable. int THREAD_PRIORITY_LOWEST Lowest available thread priority. int THREAD_PRIORITY_MORE_FAVORABLE Minimum increment to make a priority more favorable. int THREAD_PRIORITY_URGENT_AUDIO Standard priority of the most important audio threads. int THREAD_PRIORITY_URGENT_DISPLAY Standard priority of the most important display threads, for compositing the screen and retrieving input events. int THREAD_PRIORITY_VIDEO Standard priority of video threads. Viac inform\u00e1ci\u00ed o spr\u00e1ve vl\u00e1kien n\u00e1jdete v referen\u010dnej dokument\u00e1cii o triedach Thread a Process . Pomocn\u00e9 triedy pre pr\u00e1cu z vl\u00e1knami \u00b6 AsyncTask \u00b6 AsyncTask trieda je jednoduch\u00e1 a u\u017eito\u010dn\u00e1 pom\u00f4cka pre aplik\u00e1cie, ktor\u00e9 potrebuj\u00fa r\u00fdchlo presun\u00fa\u0165 pr\u00e1cu z hlavn\u00e9ho vl\u00e1kna na pracovn\u00e9 vl\u00e1kna. Napr\u00edklad ak nejak\u00e1 vstupn\u00e1 udalos\u0165 vyvol\u00e1 akciu kde je treba na\u010d\u00edta\u0165 obr\u00e1zok a n\u00e1sledne aktualizova\u0165 pou\u017e\u00edvate\u013esk\u00e9 rozhranie . Pou\u017eit\u00edm AsyncTask triedy sa jednoduch\u00fdm sp\u00f4sobom m\u00f4\u017ee presun\u00fa\u0165 bremeno s\u0165ahovania a dek\u00f3dovania obr\u00e1zku na pomocn\u00e9 pracovn\u00e9 vl\u00e1kno a n\u00e1sledne AsyncTask trieda zabezpe\u010d\u00ed odovzdanie v\u00fdsledku hlavn\u00e9mu vl\u00e1knu, ktor\u00e9 m\u00f4\u017ee pristupova\u0165 k u\u017e\u00edvate\u013esk\u00e9mu rozhraniu. Pri pou\u017e\u00edvan\u00ed AsyncTask je potrebn\u00e9 pam\u00e4ta\u0165 na nieko\u013eko d\u00f4le\u017eit\u00fdch aspektov: V predvolenom nastaven\u00ed v\u0161etky vytvoren\u00e9 AsyncTask objekty zdie\u013eaj\u00fa jedno spolo\u010dn\u00e9 vl\u00e1kno. Preto ak je v jednom momente spusten\u00fdch viacej AsyncTask-ov v skuto\u010dnosti sa sp\u00fa\u0161\u0165aj\u00fa s\u00e9riovo. Pri tejto \u0161tandardnej konfigur\u00e1cie plat\u00ed odpor\u00fa\u010danie, aby jednotliv\u00e9 AsyncTask \u00falohy vedeli svoju \u010dinnos\u0165 dokon\u010di\u0165 do 5 ms a t\u00fdm neblokovali pr\u00edli\u0161 dlho spolo\u010dn\u00e9 vl\u00e1kno. V pr\u00edpade, \u017ee potrebujete vykonanie viacero AsyncTaskov paralelne m\u00f4\u017eete tak docieli\u0165 nastaven\u00edm in\u00e9ho executora: executeOnExecutor (java.util.concurrent.Executor, Object []) s THREAD_POOL_EXECUTOR. AsyncTask \u00falohy s\u00fa tie\u017e naj\u010dastej\u0161\u00edmi p\u00e1chate\u013emi probl\u00e9mov s implicitn\u00fdmi referenciami . AsyncTask \u00falohy tie\u017e predstavuj\u00fa rizik\u00e1 spojen\u00e9 s explicitn\u00fdmi referenciami, ale v niektor\u00fdch pr\u00edpadoch je ich mo\u017en\u00e9 \u013eahko vyrie\u0161i\u0165. Napr\u00edklad AsyncTask m\u00f4\u017ee dr\u017ea\u0165 referenciu na objekt u\u017e\u00edvate\u013esk\u00e9ho rozhrania(typ View ), t\u00e1to referencia sa pou\u017e\u00edva na aktualiz\u00e1ciu u\u017e\u00edvate\u013esk\u00e9ho rozhrania. Akon\u00e1hle AsyncTask dokon\u010d\u00ed svoju pr\u00e1cu odovzd\u00e1 referenciu tohoto objekt hlavn\u00e9mu vl\u00e1knu, kde sa pou\u017eije na aktualiz\u00e1ciu u\u017e\u00edvate\u013esk\u00e9ho rozhrania. V takejto situ\u00e1cii m\u00f4\u017ee doch\u00e1dza\u0165 k memory leak-u, kedy udr\u017eiavan\u00e1 referencia bude ukazova\u0165 na objekt, ktor\u00fd u\u017e nie je pou\u017e\u00edvan\u00fd. Na vyrie\u0161enie tohoto probl\u00e9mu m\u00f4\u017eeme pou\u017ei\u0165 WeakReference na ulo\u017eenie referencie na po\u017eadovan\u00fd objekt pou\u017e\u00edvate\u013esk\u00e9ho rozhrania a na pr\u00edstup k objektu. AsyncTask je definovan\u00e1 t\u00fdmito prvkami: 3 generick\u00e9 typy 4 z\u00e1kladn\u00e9 stavy 1 pomocn\u00e1 met\u00f3da Vstupn\u00e9 parametre, Progres, V\u00fdsledok onPreExecute, doInBackground, onProgressUpdate,onPostExecute publishProgress Popis Vl\u00e1kno na ktorom sa vykon\u00e1va k\u00f3d onPreExecute() spusten\u00e9 na UI vl\u00e1kne okam\u017eite po spusten\u00ed \u00falohy. T\u00e1to met\u00f3da sa pou\u017e\u00edva na pr\u00edpravu \u00falohy, ako napr\u00edklad pripravenie u\u017e\u00edvate\u013esk\u00e9ho rozhrania(napr. zobrazenie progres-baru na pou\u017e\u00edvate\u013eskom rozhran\u00ed). hlavn\u00e9 \"UI\" vl\u00e1kno doInBackground(Params...) spusten\u00e9 na vl\u00e1kne pracuj\u00facom v pozad\u00ed hne\u010f po onPreExecute() skon\u010d\u00ed svoju \u010dinnos\u0165. V tejto met\u00f3de sa vykon\u00e1va pr\u00e1ca, ktor\u00e1 m\u00e1 be\u017ea\u0165 na pozad\u00ed. V tejto met\u00f3de m\u00f4\u017eeme vola\u0165 publishProgress(Progress...) , pomocou ktorej sa publikuj\u00fa priebe\u017en\u00e9 v\u00fdsledky. pracovn\u00e9 vl\u00e1kno onProgressUpdate(Progress...) spusten\u00e9 na UI vl\u00e1kne po zavolan\u00ed publishProgress(Progress...) met\u00f3dy. \u010cas vykonania nie je definovan\u00fd. T\u00e1to met\u00f3da sl\u00fa\u017ei na zobrazenie hocijakej formy progresu v u\u017e\u00edvate\u013eskom rozhran\u00ed. hlavn\u00e9 \"UI\" vl\u00e1kno onPostExecute(Result) spusten\u00e9 na UI vl\u00e1kne po ukon\u010den\u00ed \u00falohy na pozad\u00ed. hlavn\u00e9 \"UI\" vl\u00e1kno Uk\u00e1\u017eka interakcie hlavn\u00e9ho vl\u00e1kna s AsyncTask vl\u00e1knom Pr\u00edklad pou\u017eitia: private class VerySlowTask extends AsyncTask < String , Long , Void > { // Begin - can use UI thread here protected void onPreExecute () { } // this is the SLOW background thread taking care of heavy tasks // cannot directly change UI protected Void doInBackground ( final String ... args ) { ... publishProgress (( Long ) someLongValue ); } // periodic updates - it is OK to change UI @Override protected void onProgressUpdate ( Long ... value ) { } // End - can use UI thread here protected void onPostExecute ( final Void unused ) { } } Zru\u0161enie \u00falohy Zru\u0161i\u0165 \u00falohu m\u00f4\u017eete v \u013eubovo\u013enom \u010dase zavolan\u00edm met\u00f3dy cancel(boolean) . Po zavolan\u00ed met\u00f3dy cancel() sa vyvol\u00e1 funkcia onCancelled(Object) , a\u017e po ukon\u010den\u00ed pr\u00e1ce vo funkcii doInBackground(Object[]) . Pre ur\u00fdchlenie ukon\u010denia \u00falohy treba vo funkcii doInBackground(Object[]) periodicky kontrolova\u0165 n\u00e1vratov\u00fa hodnotu z isCancelled() . Od verzie API level R je AsyncTask trieda ozna\u010den\u00e1 ako deprecated HandlerThread \u00b6 Aj ke\u010f AsyncTask je u\u017eito\u010dn\u00fd, nemus\u00ed by\u0165 v\u017edy t\u00fdm spr\u00e1vnym rie\u0161en\u00edm probl\u00e9mu pre pr\u00e1cu s vl\u00e1knami. V niektor\u00fdch pr\u00edpadoch je potrebn\u00e9 alebo vhodnej\u0161ie pou\u017ei\u0165 tradi\u010dnej\u0161\u00ed pr\u00edstup, v ktorom existuje pracovn\u00e9 vl\u00e1kno, ktor\u00e9 ma dlh\u00fa \u017eivotnos\u0165 a tomuto vl\u00e1knu s\u00fa pride\u013eovan\u00e9 pracovn\u00e9 bloky, ktor\u00e9 s\u00fa na \u0148om vykon\u00e1van\u00e9. Uva\u017eujme o pr\u00edpade kedy z\u00edskavame sn\u00edmky z kamery pomocou Camera objektu. Po zaregistrovan\u00ed po\u017eiadavky na pr\u00edjem sn\u00edmok s n\u00e1h\u013eadom kamery, dost\u00e1vame ich v onPreviewFrame() sp\u00e4tnom volan\u00ed, ktor\u00e9 sa vyvol\u00e1 na vl\u00e1kne, z ktor\u00e9ho bolo zaregistrovan\u00e9. Ak by sa toto sp\u00e4tn\u00e9 volanie vyvolalo na hlavnom vl\u00e1kne \"UI\" , n\u00e1ro\u010dn\u00e1 \u00faloha spracovania obr\u00e1zkov by potencion\u00e1lne mohla naru\u0161i\u0165 plynul\u00e9 vykres\u013eovanie a spracovan\u00edm udalost\u00ed. Rovnak\u00fd probl\u00e9m sa t\u00fdka aj t\u00fdch AsyncTask-ov, ktor\u00e9 tie\u017e svoje \u00falohy vykon\u00e1vaj\u00fa s\u00e9riovo a m\u00f4\u017eu v pr\u00edpravnej f\u00e1ze( onPreExecute() spusten\u00e9 na hlavnom vl\u00e1kne) zablokova\u0165 hlavn\u00e9 vl\u00e1kno, ktor\u00e9 ich vytv\u00e1ra. Toto je situ\u00e1cia, ke\u010f by bolo vhodn\u00e9 pou\u017ei\u0165 HandlerThread : vl\u00e1kno obsluhy je efekt\u00edvne dlhodobo prebiehaj\u00face vl\u00e1kno, ktor\u00e9 odober\u00e1 pracovn\u00e9 bloky vo forme Runnable objektu zo z\u00e1sobn\u00edka, ktor\u00fd je sn\u00edm sp\u00e4t\u00fd. V tomto pr\u00edpade, ke\u010f aplik\u00e1cia deleguje Camera.open() pr\u00edkaz na pracovn\u00e9 vl\u00e1kno, tak v tomto priraden\u00e9 sp\u00e4tn\u00e9 volanie onPreviewFrame() bude vykon\u00e1van\u00e9 pr\u00e1ve na tomto pracovnom vl\u00e1kne, t\u00fdm p\u00e1dom UI vl\u00e1kno je odbremenen\u00e9. Ke\u010f aplik\u00e1cia vytvor\u00ed vl\u00e1kno pomocou HandlerThread , netreba zab\u00fada\u0165 na nastavenie spr\u00e1vnej priority vl\u00e1kna na z\u00e1klade charakteru vykon\u00e1vanej pr\u00e1ce. Pozn\u00e1mky na zv\u00e1\u017eenie pri pr\u00e1ci s HandlerThread HandlerThread-y be\u017eia mimo \u017eivotn\u00e9ho cyklu aktivity, tak\u017ee sa nesmie zabudn\u00fa\u0165 na ich spr\u00e1vne ukon\u010denie ak u\u017e niesu potrebn\u00e9, inak m\u00f4\u017ee doch\u00e1dza\u0165 k nechcen\u00e9mu vytv\u00e1raniu nov\u00fdch vl\u00e1kien. Toto je obzvl\u00e1\u0161\u0165 nebezpe\u010dn\u00e9, ak sa pou\u017e\u00edvaj\u00fa pre dlhodobo prebiehaj\u00face procesy. Neexistuje \u017eiadny podobn\u00fd mechanizmus na sp\u00e4tn\u00e9 odosielanie v\u00fdsledkov do hlavn\u00e9ho vl\u00e1kna ako je tu v pr\u00edpade AsyncTask-u. To znamen\u00e1 viac k\u00f3du, ktor\u00fd je potrebn\u00e9 p\u00edsa\u0165. Pr\u00e1ca s HandlerThread \u00b6 Pri pr\u00e1ci s HandlerThread je potrebn\u00e9 vytvori\u0165 a prepoji\u0165 z\u00e1sobn\u00edk spr\u00e1v a \u00faloh, z ktor\u00e9ho si bude HandlerThread odobera\u0165 \u00falohy pre svoju \u010dinnos\u0165. T\u00e1to fronta je tvoren\u00e1 objektom Handler . HandlerThread handlerThread = new HandlerThread ( \"MyHandlerThread\" ); handlerThread . start (); Looper looper = handlerThread . getLooper (); Handler handler = new Handler ( looper ); Ako prv\u00e9 vytvor\u00edme nov\u00fd HandlerThread a pomenujeme ho. Potom spust\u00edme HandlerThread, z\u00edskame Looper pre HandlerThread a odovzd\u00e1me ho Handler-ovi Z\u00e1sobn\u00edk spr\u00e1v - Handler \u00b6 Vl\u00e1kno, ktor\u00e9 chce komunikova\u0165 s hlavn\u00fdm vl\u00e1knom alebo HandlerThread vl\u00e1knom si mus\u00ed vy\u017eiada\u0165 token za pomoci met\u00f3dy obtainMessage() . Po obdr\u017ean\u00ed tokenu m\u00f4\u017ee vl\u00e1kno naplni\u0165 d\u00e1ta do token objektu a za pomoci met\u00f3dy sendMessage() tento token zaradi\u0165 do z\u00e1sobn\u00edka spr\u00e1v. Vytvoren\u00fd Handler vol\u00e1 met\u00f3du handleMessage() po prijat\u00ed novej spr\u00e1vy. Spr\u00e1va odobrat\u00e1 zo z\u00e1sobn\u00edka spr\u00e1v obsahuje d\u00e1ta alebo po\u017eiadavku na vykonanie Runnable objektu vlo\u017en\u00e9ho pomocou met\u00f3du post() . Mechanizmus odovzdania Runnable objektu alebo spr\u00e1vy. Runnable objekt predstavuje pracovn\u00fd blok, ktor\u00fd sa m\u00e1 vykona\u0165 na vl\u00e1kne pr\u00edjemcu (pracovn\u00e9 vl\u00e1kno alebo hlavn\u00e9 vl\u00e1kno). Inicializ\u00e1cia vl\u00e1kna a handlera v hlavnom vl\u00e1kne //Inicializ\u00e1cia handler vl\u00e1kna final HandlerThread backJob = new HandlerThread ( \"Vlakno casovaca\" ); backJob . start (); //Spustenie vl\u00e1kna //Pridelenie looper slu\u010dky do Handler triedy Looper mLooper = backJob . getLooper (); mHandler = new MyHandler ( mLooper ); Vytvorenie triedy handlera // Handler pre HandlerThread class MyHandler extends Handler { public MyHandler ( Looper myLooper ) { super ( myLooper ); } //Obsluha prijatia spr\u00e1vy public void handleMessage ( Message msg ) { } } Uk\u00e1\u017eka odosielania spr\u00e1vy Message msg = mHandler . obtainMessage ( 1 , data ); mHandler . sendMessage ( msg ); ThreadPool \u00b6 V praxi existuj\u00fa ur\u010dit\u00e9 druhy pr\u00e1ce, ktor\u00e9 mo\u017eno efekt\u00edvne paralelizova\u0165. Jednou z tak\u00fdchto \u00faloh je napr\u00edklad filtr\u00e1cia obr\u00e1zku po blokoch 8x8 s rozl\u00ed\u0161en\u00edm obr\u00e1zku 8 megapixelov. Tak\u00fdto druhu \u00falohy je v dne\u0161n\u00fdch viacjadrov\u00fdch zariadenia vhodn\u00e9 paralelizova\u0165 s viacer\u00fdmi vl\u00e1knami. Paralelizova\u0165 dan\u00fa \u00falohu by predstavovala pre program\u00e1tora \u00falohu manu\u00e1lne balansova\u0165 z\u00e1\u0165a\u017ee vytvoren\u00fdch vl\u00e1kien, tomuto sa ale chceme vyhn\u00fa\u0165. ThreadPoolExecutor je pomocn\u00e1 trieda na u\u013eah\u010denie tohto procesu. T\u00e1to trieda riadi vytv\u00e1ranie skupiny vl\u00e1kien, ur\u010duje ich priority a riadi rozdelenie pr\u00e1ce medzi tieto vl\u00e1kna. Ke\u010f sa pracovn\u00e9 za\u0165a\u017eenie zvy\u0161uje, trieda Executor zv\u00e4\u010d\u0161uje po\u010det vl\u00e1kien, v opa\u010dnom pr\u00edpade, ke\u010f sa za\u0165a\u017eenie zni\u017euje tak zni\u017euje aj po\u010det vl\u00e1kien. Tak to sa deje v\u017edy s prihliadnut\u00edm aby sa prisp\u00f4sobil po\u010det spusten\u00fdch vl\u00e1kien aktu\u00e1lnemu pracovn\u00e9mu za\u0165a\u017eeniu. T\u00e1to trieda tie\u017e pom\u00e1ha aplik\u00e1cii vytvori\u0165 optim\u00e1lny po\u010det vl\u00e1kien. Pri vytv\u00e1ran\u00ed ThreadPoolExecutor objektu aplik\u00e1cia nastav\u00ed minim\u00e1lny a maxim\u00e1lny po\u010det vl\u00e1kien. Preto\u017ee pracovn\u00e9 za\u0165a\u017eenie je dan\u00e9, trieda ThreadPoolExecutor vezme do \u00favahy definovan\u00e9 hodnoty minim\u00e1lneho a maxim\u00e1lneho po\u010dtu vl\u00e1kien a zv\u00e1\u017ei mno\u017estvo nevybavenej pr\u00e1ce, ktor\u00fa treba vykona\u0165. Na z\u00e1klade t\u00fdchto faktorov ThreadPoolExecutor rozhoduje o tom, ko\u013eko vl\u00e1kien by malo by\u0165 v danom okamihu na\u017eive. Vl\u00e1kna a zmeny konfigur\u00e1cie(re\u0161tart aplik\u00e1cie) \u00b6 Pri re\u0161tarte aktivity z d\u00f4vodu zmeny konfigur\u00e1cie (napr. oto\u010denie displeja) treba ma\u0165 na zreteli: aktivita, ktor\u00e1 si vytvorila vl\u00e1kno na spracovanie \u00faloh na pozad\u00ed napr. AsyncTask , mus\u00ed pri re\u0161tarte bu\u010f t\u00fato \u00falohu zru\u0161i\u0165 alebo o\u0161etri\u0165 aby dan\u00e9 vl\u00e1kno o re\u0161tarte bolo informovan\u00e9. Vo vl\u00e1kne be\u017eiacom na pozad\u00ed treba rozv\u00e1\u017ene pou\u017e\u00edva\u0165 met\u00f3du getActivity(), ktor\u00e1 m\u00f4\u017ee po\u010das re\u0161tartu aplik\u00e1cie vr\u00e1ti\u0165 in\u0161tanciu u\u017e neexistuj\u00facej aktivity. Dlhotrvaj\u00face \u00falohy na pozad\u00ed \u00b6 V predch\u00e1dzaj\u00faci \u010dasti sme sa venovali vl\u00e1knam, ktor\u00e9 sl\u00fa\u017eia na odbremenenia hlavn\u00e9ho vl\u00e1kna od pr\u00e1ce, ktor\u00e1 m\u00f4\u017ee dan\u00e9 vl\u00e1kno vy\u0165a\u017ei\u0165 a sp\u00f4sobi\u0165 tzv. zmrznutie aplik\u00e1cie. Pr\u00e1ca, ktor\u00e1 sa vykon\u00e1va na pracovn\u00fdch vl\u00e1knach ma charakter kr\u00e1tkodobej \u00falohy, ktor\u00e1 je priamo sp\u00e4t\u00e1 s aplik\u00e1ciu be\u017eiacou na popred\u00ed s ktorou u\u017e\u00edvate\u013e akt\u00edvne pracuje. Aplik\u00e1cie m\u00f4\u017eu vy\u017eadova\u0165 spustenie niektor\u00fdch \u00faloh, aj ke\u010f pou\u017e\u00edvate\u013e aplik\u00e1ciu akt\u00edvne nepou\u017e\u00edva, napr\u00edklad pravideln\u00fa synchroniz\u00e1ciu so serverom alebo pravideln\u00e9 na\u010d\u00edtavanie nov\u00e9ho obsahu v aplik\u00e1cii. Aplik\u00e1cie m\u00f4\u017eu tie\u017e vy\u017eadova\u0165, aby sa slu\u017eby spustili okam\u017eite po dokon\u010den\u00ed \u00falohy, aj ke\u010f pou\u017e\u00edvate\u013e prestal akt\u00edvne aplik\u00e1ciou pou\u017e\u00edva\u0165. T\u00e1to kapitola m\u00e1 zacie\u013e napom\u00f4c\u0165 zisti\u0165, ktor\u00e9 rie\u0161enie najlep\u0161ie vyhovuje va\u0161im potreb\u00e1m v t\u00fdchto pr\u00edpadoch pou\u017eitia. Obmedzenia Android OS, ktor\u00e9 ovplyv\u0148uj\u00fa vykon\u00e1vanie \u00faloh na pozad\u00ed \u00b6 Aby sa maximalizovala v\u00fddr\u017e bat\u00e9rie a vyn\u00fatilo sa dobr\u00e9 spr\u00e1vanie aplik\u00e1cie, Android obmedzuje pr\u00e1cu na pozad\u00ed, ke\u010f pou\u017e\u00edvate\u013e akt\u00edvne nevyu\u017e\u00edva aplik\u00e1ciu (notifik\u00e1cia na slu\u017ebu). Android 6.0 (API \u00farove\u0148 23) predstavil re\u017eim Doze a pohotovostn\u00fd re\u017eim aplik\u00e1cie . Re\u017eim Doze obmedzuje spr\u00e1vanie aplik\u00e1cie, ke\u010f je obrazovka vypnut\u00e1 a zariadenie je nehybn\u00e9 (le\u017e\u00ed na stole bez pohnutia). Pohotovostn\u00fd re\u017eim stavia nepou\u017e\u00edvan\u00e9 aplik\u00e1cie do \u0161peci\u00e1lneho stavu, ktor\u00fd obmedzuje ich pr\u00edstup k sieti, \u00falohy a synchroniz\u00e1ciu. Android 7.0 (API \u00farove\u0148 24) obmedzoval implicitn\u00e9 vysielanie a predstavil Doze-on-the-Go . Android 8.0 (API \u00farove\u0148 26) \u010falej obmedzoval chovanie na pozad\u00ed , napr\u00edklad z\u00edskavanie polohy na pozad\u00ed a uvo\u013e\u0148ovanie wakelokov z pam\u00e4ti. Android 9 (API \u00farove\u0148 28) predstavil segmenty pohotovostn\u00e9ho re\u017eimu pre aplik\u00e1cie , v ktor\u00fdch s\u00fa \u017eiadosti o prostriedky na zdroje dynamicky uprednost\u0148ovan\u00e9 na z\u00e1klade vzorov pou\u017e\u00edvania aplik\u00e1ci\u00ed. WorkManager \u00b6 Ur\u010den\u00e9 pre: nez\u00e1visl\u00e1 \u00faloha s predpokladom, \u017ee m\u00e1 be\u017ea\u0165 aj ke\u010f aplik\u00e1cia alebo zariadenia sa re\u0161tartuje spustenie \u00falohy pri splnen\u00ed syst\u00e9mov\u00fdch po\u017eiadaviek(napr. dostupn\u00e1 sie\u0165, bat\u00e9ria je nabit\u00e1) s\u00fa\u010das\u0165 AndroidX sp\u00e4tn\u00e1 kompatibilita a\u017e na API level 14 WorkManager tie\u017e podporuje sp\u00fa\u0161\u0165anie \u00faloh ako slu\u017ebu v popred\u00ed(Foreground service), \u010do je ide\u00e1lne, ke\u010f \u00faloha by nemala by\u0165 preru\u0161en\u00e1. Foreground services / Slu\u017eba v popred\u00ed \u00b6 Pre pr\u00e1cu iniciovan\u00fa pou\u017e\u00edvate\u013eom, ktor\u00e1 mus\u00ed by\u0165 spusten\u00e1 okam\u017eite a mus\u00ed by\u0165 vykonan\u00e1 a\u017e do ukon\u010denia. Pou\u017e\u00edvanie slu\u017eby foreground service povie syst\u00e9mu, \u017ee aplik\u00e1cia rob\u00ed nie\u010do d\u00f4le\u017eit\u00e9 a nemala by by\u0165 zabit\u00e1. Slu\u017eby popredia s\u00fa pre pou\u017e\u00edvate\u013eov vidite\u013en\u00e9 prostredn\u00edctvom ozn\u00e1menia(notofication), ktor\u00e9 sa ned\u00e1 zru\u0161i\u0165 AlarmManager \u00b6 Ak potrebujete spusti\u0165 \u00falohu v presnom \u010dase, pou\u017eite AlarmManager. AlarmManager v pr\u00edpade potreby spust\u00ed va\u0161u aplik\u00e1ciu na vykonanie \u00falohy v \u010dase, ktor\u00fd ur\u010d\u00edte. Ak v\u0161ak va\u0161a pr\u00e1ca nemus\u00ed prebieha\u0165 v presnom \u010dase, WorkManager je lep\u0161ou mo\u017enos\u0165ou. WorkManager dok\u00e1\u017ee lep\u0161ie vyv\u00e1\u017ei\u0165 syst\u00e9mov\u00e9 prostriedky. Napr\u00edklad, ak potrebujete spusti\u0165 \u00falohu ka\u017ed\u00fa hodinu, ale nie potrebn\u00e9 \u00faplne presn\u00e9 na\u010dasovanie, mali by ste pou\u017ei\u0165 WorkManagerna a nastavi\u0165 opakuj\u00facu sa \u00falohu. DownloadManager \u00b6 stiahnutie ve\u013ek\u00fdch s\u00faborov alebo ve\u013ea s\u00faborov cez HTTP, zv\u00e1\u017ete pou\u017eitie DownloadManager stiahnutie vykon\u00e1 na pozad\u00ed, pri\u010dom sa postar\u00e1 o interakcie s HTTP opakovan\u00e9 stiahnutie pri zlyhaniach alebo pri zmen\u00e1ch pripojenia a re\u0161tartovan\u00ed syst\u00e9mu","title":"Procesy a vl\u00e1kna <small>(multithreding)</small>"},{"location":"#procesy-a-vlakna-multithreding","text":"Android develoment Pri spusten\u00ed aplik\u00e1cie Android OS spust\u00ed nov\u00fd proces (Linux) s jedn\u00fdm vl\u00e1knom. \u0160tandardne v\u0161etky komponenty aplik\u00e1cie be\u017eia na rovnakom procese v tzv. \"hlavnom\" vl\u00e1kne v Android-e tie\u017e naz\u00fdvan\u00e9 UI vl\u00e1kno. Toto \u0161tandardn\u00e9 spr\u00e1vanie sa d\u00e1 ovplyvni\u0165 v manifeste AndroidManifest.xml a takisto v ka\u017edom procese je mo\u017en\u00e9 vytvori\u0165 \u010fal\u0161ie vl\u00e1kna.","title":"Procesy a vl\u00e1kna (multithreding)"},{"location":"#procesy","text":"V predvolenom nastaven\u00ed s\u00fa v\u0161etky komponenty tej istej aplik\u00e1cie spusten\u00e9 v rovnakom procese a v\u00e4\u010d\u0161ina aplik\u00e1ci\u00ed by to nemala meni\u0165. Ak v\u0161ak je potrebn\u00e9 zmeni\u0165 zaradenie do ktor\u00e9ho procesu dan\u00e1 komponenta patr\u00ed, m\u00f4\u017eeme tak spravi\u0165 v s\u00fabore AndroidManifest.xml : Komponenty ako <activity>, <service>, <receiver>, <provider> podporuj\u00fa atrib\u00fat android:process , pomocou ktor\u00e9ho m\u00f4\u017eeme upravi\u0165 v akom procese maj\u00fa komponenty be\u017ea\u0165 (vlastn\u00fd proces, zdielan\u00fd proces). Komponent <application> umo\u017e\u0148uje nastavi\u0165 atrib\u00fat android:process , ktor\u00fdm sa nastav\u00ed predvolen\u00e1 hodnota. V pr\u00edpadoch kedy Android potrebuje uvolni\u0165 HW prostriedky alebo \u0161etri\u0165 energiou sa m\u00f4\u017ee rozhodn\u00fa\u0165 ne\u010dinn\u00e9 procesy zastavi\u0165. Ak niektor\u00e9 zastavan\u00e9 komponenty maj\u00fa op\u00e4tovne pridelen\u00fa pr\u00e1cu tak s\u00fa znova spusten\u00e9 v procese. Pre spr\u00e1vne fungovanie aplik\u00e1cie je potrebn\u00e9 spr\u00e1vne implementova\u0165 \u017eivotn\u00fd cyklus procesu (predch\u00e1dzaj\u00face predn\u00e1\u0161ky a cvi\u010denia).","title":"Procesy"},{"location":"#vlakna","text":"Pri spusten\u00ed aplik\u00e1cie syst\u00e9m vytvor\u00ed pre aplik\u00e1ciu vl\u00e1kno, ktor\u00e9 sa naz\u00fdva hlavn\u00e9 vl\u00e1kno alebo niekedy tie\u017e \"UI\" vl\u00e1kno. Toto vl\u00e1kno je d\u00f4le\u017eit\u00e9, preto\u017ee m\u00e1 na starosti odosielanie udalost\u00ed na pr\u00edslu\u0161n\u00e9 komponenty u\u017e\u00edvate\u013esk\u00e9ho rozhrania. Dan\u00e9 vl\u00e1kno je zodpovedn\u00e9 aj za samotn\u00e9 vykres\u013eovanie UI. Za zvl\u00e1\u0161tnych okolnost\u00ed v\u0161ak hlavn\u00e9 vl\u00e1kno aplik\u00e1cie nemus\u00ed by\u0165 toto\u017en\u00e9 s UI vl\u00e1knom. Ako je v\u0161ak uveden\u00e9 v dokument\u00e1cii, rozdiel je d\u00f4le\u017eit\u00fd iba v s\u00favislosti s niektor\u00fdmi syst\u00e9mov\u00fdmi aplik\u00e1ciami (aplik\u00e1ciami, ktor\u00e9 s\u00fa spusten\u00e9 ako s\u00fa\u010das\u0165 OS). \u010eal\u0161ie inform\u00e1cie sa nach\u00e1dzaj\u00fa v t\u00e9me Annotations Thread .","title":"Vl\u00e1kna"},{"location":"#hlavne-ui-vlakno","text":"Hlavn\u00e9 vl\u00e1kno m\u00e1 jednoduch\u00fd dizajn: Jeho jedinou \u00falohou je \u010daka\u0165 na pridelenie \u00falohy z pracovnej fronty a n\u00e1sledne jej vykonanie. Tieto \u00falohy prich\u00e1dzaj\u00fa z r\u00f4znych zdrojov ako napr. udalosti sp\u00e4t\u00e9 zo \u017eivotn\u00fdm cyklom aplik\u00e1cie, udalosti od u\u017e\u00edvate\u013esk\u00e9ho rozhrania, udalosti od ostatn\u00fdch aplik\u00e1ci\u00ed. Pridelen\u00e1 \u00faloha sa spracov\u00e1va v r\u00f4znych obslu\u017en\u00fdch met\u00f3dach ako napr.: v obslu\u017en\u00fdch met\u00f3dach \u017eivotn\u00e9ho cyklu onStart(),onResume(),onRestart(), onCreate(),onPause(),onStop(), onDestroy() , at\u010f v obslu\u017en\u00fdch met\u00f3dach u\u017e\u00edvate\u013esk\u00e9ho rozhrania onClick(), onKeyDown() , at\u010f Uk\u00e1\u017eka \u010dinnosti hlavn\u00e9ho vl\u00e1kna Hlavn\u00e9 vl\u00e1kno m\u00e1 tie\u017e za \u00falohu v pravideln\u00fdch intervaloch vykres\u013eova\u0165 u\u017e\u00edvate\u013esk\u00e9 rozhranie (ka\u017ed\u00fdch 16ms \u010do je 60Hz). Ak hlavn\u00e9 vl\u00e1kno vykon\u00e1va nejak\u00fa \u010dasovo n\u00e1ro\u010dn\u00fa \u00falohou alebo je zahlten\u00e9 ve\u013ek\u00fdm mno\u017estvom udalost\u00ed na spracovanie tak u\u017e\u00edvate\u013esk\u00e9 rozhranie m\u00f4\u017ee by\u0165 spomalen\u00e9. Ak hlavn\u00e9 vl\u00e1kno sa zablokuje pribli\u017ene na p\u00e4\u0165 sek\u00fand, syst\u00e9m zobraz\u00ed dial\u00f3gov\u00e9 okno: aplik\u00e1ciu neodpoved\u00e1 (ANR), ktor\u00e9 umo\u017e\u0148uje pou\u017e\u00edvate\u013eovi zatvori\u0165 aplik\u00e1ciu. Norm\u00e1lna \u010dinnos\u0165 hlavn\u00e9ho vl\u00e1kna Zablokovanie hlavn\u00e9ho vl\u00e1kna Presunutie n\u00e1ro\u010denej oper\u00e1cie na pracovn\u00e9 vl\u00e1kno Ak hlavn\u00e9 vl\u00e1kno sa zablokuje pribli\u017ene na p\u00e4\u0165 sek\u00fand, syst\u00e9m zobraz\u00ed dial\u00f3gov\u00e9 okno Najv\u00e4\u010d\u0161\u00edm d\u00f4vodom na zav\u00e1dzanie vl\u00e1kien do aplik\u00e1cie je presun v\u00fdpo\u010dtovo n\u00e1ro\u010dn\u00fdch \u00faloh z hlavn\u00e9ho vl\u00e1kna preto, aby neovplyv\u0148ovali plynulos\u0165 vykres\u013eovania a r\u00fdchlos\u0165 reakcie na vstup pou\u017e\u00edvate\u013ea. Vl\u00e1kna, ktor\u00e9 odbreme\u0148uj\u00fa hlavn\u00e9 vl\u00e1kno, budeme naz\u00fdva\u0165 pracovn\u00fdmi vl\u00e1knami . Pr\u00edstup k met\u00f3dam u\u017e\u00edvate\u013esk\u00e9ho rozhrania nie je s poh\u013eadu viacvl\u00e1knovej aplik\u00e1cie bezpe\u010dn\u00fd a teda priamy pr\u00edstup k t\u00fdmto met\u00f3da z in\u00e9ho vl\u00e1kna ako je hlavn\u00e9 vl\u00e1kno je zak\u00e1zan\u00fd. StrictMode \u2013 n\u00e1stroj na detekciu omylov v k\u00f3de, ktor\u00e9 m\u00f4\u017eu sp\u00f4sobova\u0165 ANR hl\u00e1\u0161ky StrictMode je n\u00e1stroj pre v\u00fdvoj\u00e1rov, ktor\u00fd m\u00e1 za \u00falohu upozor\u0148ova\u0165 na chyby z nepozornosti aby ste ich mohli opravi\u0165. StrictMode sa naj\u010dastej\u0161ie pou\u017e\u00edva na odhalenie n\u00e1hodn\u00e9ho pr\u00edstupu na disk alebo do siete v hlavnom vl\u00e1kne aplik\u00e1cie, kde sa \u0161tandardne vykon\u00e1vaj\u00fa iba oper\u00e1cie t\u00fdkaj\u00face sa u\u017evatelsk\u00e9 rozhrania. Udr\u017eiavanie diskov\u00fdch a sie\u0165ov\u00fdch oper\u00e1ci\u00ed mimo hlavn\u00e9ho vl\u00e1kna m\u00e1 pozit\u00edvny vplyv na plynulos\u0165 a r\u00fdchlu odozvu aplik\u00e1cie. public void onCreate () { if ( DEVELOPER_MODE ) { StrictMode . setThreadPolicy ( new ThreadPolicy . Builder () . detectDiskReads () . detectDiskWrites () . detectNetwork () // or .detectAll () pre v\u0161etky zistite\u013en\u00e9 probl\u00e9my . penaltyLog () . build () ; StrictMode . setVmPolicy ( new VmPolicy . Builder () . detectLeakedSqlLiteObjects () . detectLeakedClosableObjects () . penaltyLog () . penaltyDeath () . build ()); } super . onCreate (); } Vylep\u0161ite kontrolu k\u00f3du pomocou anot\u00e1ci\u00ed Android podporuje mno\u017estvo anot\u00e1ci\u00ed prostredn\u00edctvom Kni\u017enice podpory anot\u00e1ci\u00ed . Kni\u017enicu m\u00f4\u017eete z\u00edska\u0165 prostredn\u00edctvom android.support.annotation bal\u00edka. Ak chcete do svojho projektu prida\u0165 kni\u017enicu na podporu anot\u00e1ci\u00ed, do dependencies bloku v s\u00fabore build.gradle pridajte nasleduj\u00faci riadok a zosynchronizujte projekt: dependencies { implementation 'com.android.support:support-annotations:28.0.0' } Ak chcete spusti\u0165 kontrolu k\u00f3du z Android Studia, ktor\u00e1 zah\u0155\u0148a overenie anot\u00e1ci\u00ed a automatick\u00fa kontrolu pomocou programu Lint, na paneli s ponukami vyberte Analyzova\u0165 > Skontrolova\u0165 k\u00f3d ( Analyze > Inspect Code ). Upozor\u0148ujeme, \u017ee hoci konflikty anot\u00e1ci\u00ed generuj\u00fa upozornenia, tieto upozornenia nebr\u00e1nia kompil\u00e1cii aplik\u00e1cie. Naj\u010dastej\u0161ie pou\u017e\u00edvan\u00e9 anot\u00e1cie anot\u00e1cii: Kotrola null hodn\u00f4t: @Nullable @NonNull Anot\u00e1cie zdrojov: napr. @DrawableRes, @DimenRes, @ColorResa @InterpolatorRes, @StringRes Anot\u00e1cie na obmedzenie vstupn\u00fdch hodn\u00f4t napr. @IntRange, @FloatRangea, @Size Anot\u00e1cie k povoleniam napr. @RequiresPermission Anot\u00e1cie na kontrolu, \u010di sa met\u00f3da vol\u00e1 z konkr\u00e9tneho typu vl\u00e1kna @MainThread @UiThread @WorkerThread @BinderThread @AnyThread Ostatn\u00e9 si mo\u017eete dohlada\u0165 tu Ako u\u017e bolo p\u00edsan\u00e9 v predch\u00e1dzaj\u00facich odsekoch na hlavnom vl\u00e1kne sa nesm\u00fa vykon\u00e1va\u0165 \u010dasovo n\u00e1ro\u010dn\u00e9 \u00falohy, ktor\u00e9 by mohli toto vl\u00e1kno zablokova\u0165. V\u0161etky n\u00e1ro\u010dnej\u0161ie \u00falohy by sa mali vykon\u00e1va\u0165 na pracovn\u00fdch vl\u00e1knach, ktor\u00e9 s\u00fa riaden\u00e9 z hlavn\u00e9ho vl\u00e1kna. Treba pripomen\u00fa\u0165, \u017ee pr\u00e1ca z u\u017e\u00edvate\u013esk\u00fdm rozhran\u00edm je dovolen\u00e1 iba z hlavn\u00e9ho vl\u00e1kna. Na vyrie\u0161enie probl\u00e9mu s pr\u00edstupom k u\u017e\u00edvate\u013esk\u00e9mu rozhranie mimo hlavn\u00e9ho vl\u00e1kna Android poskytuje viacero mo\u017enost\u00ed: Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) Pr\u00edklad aktualiz\u00e1cie u\u017e\u00e1vate\u013esk\u00e9ho rozhrania z pracovn\u00e9ho vl\u00e1kna pomocu odoslania Runnable objektu public void onClick ( View v ) { new Thread ( new Runnable () { public void run () { // potenci\u00e1lne \u010dasovo n\u00e1ro\u010dn\u00e1 \u00faloha final Bitmap bitmap = processBitMap ( \"image.png\" ); imageView . post ( new Runnable () { public void run () { imageView . setImageBitmap ( bitmap ); } }); } }). start (); } Oper\u00e1cia \u00fapravy obr\u00e1zku sa vykon\u00e1va zo samostatn\u00e9ho vl\u00e1kna, zatia\u013e \u010do s objektom ImageView sa v\u017edy manipuluje z hlavn\u00e9ho vl\u00e1kna (UI). ``` Z rast\u00facou zlo\u017eitos\u0165ou aplik\u00e1cie m\u00f4\u017ee priame pou\u017e\u00edvanie vl\u00e1ken by\u0165 kompilovan\u00e9 a nepreh\u013eadn\u00e9. Android poskytuje efekt\u00edvnej\u0161ie sp\u00f4soby ako pracova\u0165 s \u00falohami na pozad\u00ed: Vykonanie n\u00e1ro\u010dn\u00fdch v\u00fdpo\u010dtov na pozad\u00ed za pomoci service komponenty syst\u00e9mu a vyu\u017eitia notifik\u00e1cii ( notifications ) pre informovanie pou\u017e\u00edvate\u013ea. IntentService, Foreground service Vykonanie n\u00e1ro\u010dn\u00fdch v\u00fdpo\u010dtov pomocou vl\u00e1kna . Spolupr\u00e1ca a komunik\u00e1cia medzi vl\u00e1knami je mo\u017en\u00e1 pomocou obslu\u017en\u00fdch Handler objektov a posielania Runnable objektov. AsyncTask, AsyncTaskLoader, HandlerThread, ThreadPool \u0160pecializovan\u00e9 kni\u017enice WorkManager, AlarmManager, DownloadManager","title":"Hlavn\u00e9 \"UI\" vl\u00e1kno"},{"location":"#nastavenie-priority","text":"Priorita, ktor\u00fa dostan\u00fa vl\u00e1kna v aplik\u00e1ci\u00ed, z\u00e1vis\u00ed \u010diasto\u010dne od toho, kde sa aplik\u00e1cia nach\u00e1dza v \u017eivotnom cykle aplik\u00e1cie. Pri vytv\u00e1ran\u00ed a spr\u00e1ve vl\u00e1kien je d\u00f4le\u017eit\u00e9 nastavi\u0165 ich prioritu. Ak je nastaven\u00e1 pr\u00edli\u0161 vysoko, va\u0161e vl\u00e1kno m\u00f4\u017ee preru\u0161i\u0165 vl\u00e1kno UI a RenderThread, \u010do m\u00f4\u017ee sp\u00f4sobi\u0165, \u017ee aplik\u00e1cia vynech\u00e1 r\u00e1mce pri vykres\u013eovan\u00ed UI. Opa\u010dn\u00fd extr\u00e9m je ak je nastaven\u00e1 pr\u00edli\u0161 n\u00edzka priorita, \u010do m\u00f4\u017ee sp\u00f4sobi\u0165, \u017ee asynchr\u00f3nne \u00falohy (napr\u00edklad na\u010d\u00edtanie obr\u00e1zkov) bud\u00fa pr\u00edli\u0161 spomalen\u00e9. V\u017edy, ke\u010f je vytvoren\u00e9 nov\u00e9 vl\u00e1kno je vhodn\u00e9 zavola\u0165 setThreadPriority() a nastavi\u0165 vl\u00e1knu vhodn\u00fa prioritu tak aby pl\u00e1nova\u010d vybalancoval vyta\u017eenie CPU. Pre jednoduch\u0161ie zvolenie spr\u00e1vnej priority existuj\u00fa pomocn\u00e9 kon\u0161tanty cez ktor\u00e9 m\u00f4\u017eete zvoli\u0165 spr\u00e1vnu prioritu vi\u010f. tabu\u013eka ni\u017e\u0161ie. Napr\u00edklad THREAD_PRIORITY_DEFAULT predstavuje predvolen\u00fa hodnotu pre vl\u00e1kno. Aplik\u00e1cia by mala nastavi\u0165 prioritu THREAD_PRIORITY_BACKGROUND pre vl\u00e1kna, ktor\u00e9 vykon\u00e1vaj\u00fa menej naliehav\u00fa pr\u00e1cu. Vl\u00e1kna, ktor\u00e9 s\u00fa v aplik\u00e1cii, ktor\u00e1 je v popred\u00ed zvy\u010dajne z\u00edskavaj\u00fa asi 95% procesn\u00e9ho \u010dasu , zatia\u013e \u010do vl\u00e1kna v aplik\u00e1cii v pozad\u00ed z\u00edskavaj\u00fa iba zhruba 5%. V predvolenom nastaven\u00ed syst\u00e9m nastav\u00ed prioritu vl\u00e1kna na rovnak\u00fa prioritu a \u010dlenstvo v skupine ako vl\u00e1kno, ktor\u00e9 vytvorilo nov\u00e9 vl\u00e1kno. Kon\u0161tanta int THREAD_PRIORITY_AUDIO Standard priority of audio threads. int THREAD_PRIORITY_BACKGROUND Standard priority background threads. int THREAD_PRIORITY_DEFAULT Standard priority of application threads. int THREAD_PRIORITY_DISPLAY Standard priority of system display threads, involved in updating the user interface. int THREAD_PRIORITY_FOREGROUND Standard priority of threads that are currently running a user interface that the user is interacting with. int THREAD_PRIORITY_LESS_FAVORABLE Minimum increment to make a priority less favorable. int THREAD_PRIORITY_LOWEST Lowest available thread priority. int THREAD_PRIORITY_MORE_FAVORABLE Minimum increment to make a priority more favorable. int THREAD_PRIORITY_URGENT_AUDIO Standard priority of the most important audio threads. int THREAD_PRIORITY_URGENT_DISPLAY Standard priority of the most important display threads, for compositing the screen and retrieving input events. int THREAD_PRIORITY_VIDEO Standard priority of video threads. Viac inform\u00e1ci\u00ed o spr\u00e1ve vl\u00e1kien n\u00e1jdete v referen\u010dnej dokument\u00e1cii o triedach Thread a Process .","title":"Nastavenie priority"},{"location":"#pomocne-triedy-pre-pracu-z-vlaknami","text":"","title":"Pomocn\u00e9 triedy pre pr\u00e1cu z vl\u00e1knami"},{"location":"#asynctask","text":"AsyncTask trieda je jednoduch\u00e1 a u\u017eito\u010dn\u00e1 pom\u00f4cka pre aplik\u00e1cie, ktor\u00e9 potrebuj\u00fa r\u00fdchlo presun\u00fa\u0165 pr\u00e1cu z hlavn\u00e9ho vl\u00e1kna na pracovn\u00e9 vl\u00e1kna. Napr\u00edklad ak nejak\u00e1 vstupn\u00e1 udalos\u0165 vyvol\u00e1 akciu kde je treba na\u010d\u00edta\u0165 obr\u00e1zok a n\u00e1sledne aktualizova\u0165 pou\u017e\u00edvate\u013esk\u00e9 rozhranie . Pou\u017eit\u00edm AsyncTask triedy sa jednoduch\u00fdm sp\u00f4sobom m\u00f4\u017ee presun\u00fa\u0165 bremeno s\u0165ahovania a dek\u00f3dovania obr\u00e1zku na pomocn\u00e9 pracovn\u00e9 vl\u00e1kno a n\u00e1sledne AsyncTask trieda zabezpe\u010d\u00ed odovzdanie v\u00fdsledku hlavn\u00e9mu vl\u00e1knu, ktor\u00e9 m\u00f4\u017ee pristupova\u0165 k u\u017e\u00edvate\u013esk\u00e9mu rozhraniu. Pri pou\u017e\u00edvan\u00ed AsyncTask je potrebn\u00e9 pam\u00e4ta\u0165 na nieko\u013eko d\u00f4le\u017eit\u00fdch aspektov: V predvolenom nastaven\u00ed v\u0161etky vytvoren\u00e9 AsyncTask objekty zdie\u013eaj\u00fa jedno spolo\u010dn\u00e9 vl\u00e1kno. Preto ak je v jednom momente spusten\u00fdch viacej AsyncTask-ov v skuto\u010dnosti sa sp\u00fa\u0161\u0165aj\u00fa s\u00e9riovo. Pri tejto \u0161tandardnej konfigur\u00e1cie plat\u00ed odpor\u00fa\u010danie, aby jednotliv\u00e9 AsyncTask \u00falohy vedeli svoju \u010dinnos\u0165 dokon\u010di\u0165 do 5 ms a t\u00fdm neblokovali pr\u00edli\u0161 dlho spolo\u010dn\u00e9 vl\u00e1kno. V pr\u00edpade, \u017ee potrebujete vykonanie viacero AsyncTaskov paralelne m\u00f4\u017eete tak docieli\u0165 nastaven\u00edm in\u00e9ho executora: executeOnExecutor (java.util.concurrent.Executor, Object []) s THREAD_POOL_EXECUTOR. AsyncTask \u00falohy s\u00fa tie\u017e naj\u010dastej\u0161\u00edmi p\u00e1chate\u013emi probl\u00e9mov s implicitn\u00fdmi referenciami . AsyncTask \u00falohy tie\u017e predstavuj\u00fa rizik\u00e1 spojen\u00e9 s explicitn\u00fdmi referenciami, ale v niektor\u00fdch pr\u00edpadoch je ich mo\u017en\u00e9 \u013eahko vyrie\u0161i\u0165. Napr\u00edklad AsyncTask m\u00f4\u017ee dr\u017ea\u0165 referenciu na objekt u\u017e\u00edvate\u013esk\u00e9ho rozhrania(typ View ), t\u00e1to referencia sa pou\u017e\u00edva na aktualiz\u00e1ciu u\u017e\u00edvate\u013esk\u00e9ho rozhrania. Akon\u00e1hle AsyncTask dokon\u010d\u00ed svoju pr\u00e1cu odovzd\u00e1 referenciu tohoto objekt hlavn\u00e9mu vl\u00e1knu, kde sa pou\u017eije na aktualiz\u00e1ciu u\u017e\u00edvate\u013esk\u00e9ho rozhrania. V takejto situ\u00e1cii m\u00f4\u017ee doch\u00e1dza\u0165 k memory leak-u, kedy udr\u017eiavan\u00e1 referencia bude ukazova\u0165 na objekt, ktor\u00fd u\u017e nie je pou\u017e\u00edvan\u00fd. Na vyrie\u0161enie tohoto probl\u00e9mu m\u00f4\u017eeme pou\u017ei\u0165 WeakReference na ulo\u017eenie referencie na po\u017eadovan\u00fd objekt pou\u017e\u00edvate\u013esk\u00e9ho rozhrania a na pr\u00edstup k objektu. AsyncTask je definovan\u00e1 t\u00fdmito prvkami: 3 generick\u00e9 typy 4 z\u00e1kladn\u00e9 stavy 1 pomocn\u00e1 met\u00f3da Vstupn\u00e9 parametre, Progres, V\u00fdsledok onPreExecute, doInBackground, onProgressUpdate,onPostExecute publishProgress Popis Vl\u00e1kno na ktorom sa vykon\u00e1va k\u00f3d onPreExecute() spusten\u00e9 na UI vl\u00e1kne okam\u017eite po spusten\u00ed \u00falohy. T\u00e1to met\u00f3da sa pou\u017e\u00edva na pr\u00edpravu \u00falohy, ako napr\u00edklad pripravenie u\u017e\u00edvate\u013esk\u00e9ho rozhrania(napr. zobrazenie progres-baru na pou\u017e\u00edvate\u013eskom rozhran\u00ed). hlavn\u00e9 \"UI\" vl\u00e1kno doInBackground(Params...) spusten\u00e9 na vl\u00e1kne pracuj\u00facom v pozad\u00ed hne\u010f po onPreExecute() skon\u010d\u00ed svoju \u010dinnos\u0165. V tejto met\u00f3de sa vykon\u00e1va pr\u00e1ca, ktor\u00e1 m\u00e1 be\u017ea\u0165 na pozad\u00ed. V tejto met\u00f3de m\u00f4\u017eeme vola\u0165 publishProgress(Progress...) , pomocou ktorej sa publikuj\u00fa priebe\u017en\u00e9 v\u00fdsledky. pracovn\u00e9 vl\u00e1kno onProgressUpdate(Progress...) spusten\u00e9 na UI vl\u00e1kne po zavolan\u00ed publishProgress(Progress...) met\u00f3dy. \u010cas vykonania nie je definovan\u00fd. T\u00e1to met\u00f3da sl\u00fa\u017ei na zobrazenie hocijakej formy progresu v u\u017e\u00edvate\u013eskom rozhran\u00ed. hlavn\u00e9 \"UI\" vl\u00e1kno onPostExecute(Result) spusten\u00e9 na UI vl\u00e1kne po ukon\u010den\u00ed \u00falohy na pozad\u00ed. hlavn\u00e9 \"UI\" vl\u00e1kno Uk\u00e1\u017eka interakcie hlavn\u00e9ho vl\u00e1kna s AsyncTask vl\u00e1knom Pr\u00edklad pou\u017eitia: private class VerySlowTask extends AsyncTask < String , Long , Void > { // Begin - can use UI thread here protected void onPreExecute () { } // this is the SLOW background thread taking care of heavy tasks // cannot directly change UI protected Void doInBackground ( final String ... args ) { ... publishProgress (( Long ) someLongValue ); } // periodic updates - it is OK to change UI @Override protected void onProgressUpdate ( Long ... value ) { } // End - can use UI thread here protected void onPostExecute ( final Void unused ) { } } Zru\u0161enie \u00falohy Zru\u0161i\u0165 \u00falohu m\u00f4\u017eete v \u013eubovo\u013enom \u010dase zavolan\u00edm met\u00f3dy cancel(boolean) . Po zavolan\u00ed met\u00f3dy cancel() sa vyvol\u00e1 funkcia onCancelled(Object) , a\u017e po ukon\u010den\u00ed pr\u00e1ce vo funkcii doInBackground(Object[]) . Pre ur\u00fdchlenie ukon\u010denia \u00falohy treba vo funkcii doInBackground(Object[]) periodicky kontrolova\u0165 n\u00e1vratov\u00fa hodnotu z isCancelled() . Od verzie API level R je AsyncTask trieda ozna\u010den\u00e1 ako deprecated","title":"AsyncTask "},{"location":"#handlerthread","text":"Aj ke\u010f AsyncTask je u\u017eito\u010dn\u00fd, nemus\u00ed by\u0165 v\u017edy t\u00fdm spr\u00e1vnym rie\u0161en\u00edm probl\u00e9mu pre pr\u00e1cu s vl\u00e1knami. V niektor\u00fdch pr\u00edpadoch je potrebn\u00e9 alebo vhodnej\u0161ie pou\u017ei\u0165 tradi\u010dnej\u0161\u00ed pr\u00edstup, v ktorom existuje pracovn\u00e9 vl\u00e1kno, ktor\u00e9 ma dlh\u00fa \u017eivotnos\u0165 a tomuto vl\u00e1knu s\u00fa pride\u013eovan\u00e9 pracovn\u00e9 bloky, ktor\u00e9 s\u00fa na \u0148om vykon\u00e1van\u00e9. Uva\u017eujme o pr\u00edpade kedy z\u00edskavame sn\u00edmky z kamery pomocou Camera objektu. Po zaregistrovan\u00ed po\u017eiadavky na pr\u00edjem sn\u00edmok s n\u00e1h\u013eadom kamery, dost\u00e1vame ich v onPreviewFrame() sp\u00e4tnom volan\u00ed, ktor\u00e9 sa vyvol\u00e1 na vl\u00e1kne, z ktor\u00e9ho bolo zaregistrovan\u00e9. Ak by sa toto sp\u00e4tn\u00e9 volanie vyvolalo na hlavnom vl\u00e1kne \"UI\" , n\u00e1ro\u010dn\u00e1 \u00faloha spracovania obr\u00e1zkov by potencion\u00e1lne mohla naru\u0161i\u0165 plynul\u00e9 vykres\u013eovanie a spracovan\u00edm udalost\u00ed. Rovnak\u00fd probl\u00e9m sa t\u00fdka aj t\u00fdch AsyncTask-ov, ktor\u00e9 tie\u017e svoje \u00falohy vykon\u00e1vaj\u00fa s\u00e9riovo a m\u00f4\u017eu v pr\u00edpravnej f\u00e1ze( onPreExecute() spusten\u00e9 na hlavnom vl\u00e1kne) zablokova\u0165 hlavn\u00e9 vl\u00e1kno, ktor\u00e9 ich vytv\u00e1ra. Toto je situ\u00e1cia, ke\u010f by bolo vhodn\u00e9 pou\u017ei\u0165 HandlerThread : vl\u00e1kno obsluhy je efekt\u00edvne dlhodobo prebiehaj\u00face vl\u00e1kno, ktor\u00e9 odober\u00e1 pracovn\u00e9 bloky vo forme Runnable objektu zo z\u00e1sobn\u00edka, ktor\u00fd je sn\u00edm sp\u00e4t\u00fd. V tomto pr\u00edpade, ke\u010f aplik\u00e1cia deleguje Camera.open() pr\u00edkaz na pracovn\u00e9 vl\u00e1kno, tak v tomto priraden\u00e9 sp\u00e4tn\u00e9 volanie onPreviewFrame() bude vykon\u00e1van\u00e9 pr\u00e1ve na tomto pracovnom vl\u00e1kne, t\u00fdm p\u00e1dom UI vl\u00e1kno je odbremenen\u00e9. Ke\u010f aplik\u00e1cia vytvor\u00ed vl\u00e1kno pomocou HandlerThread , netreba zab\u00fada\u0165 na nastavenie spr\u00e1vnej priority vl\u00e1kna na z\u00e1klade charakteru vykon\u00e1vanej pr\u00e1ce. Pozn\u00e1mky na zv\u00e1\u017eenie pri pr\u00e1ci s HandlerThread HandlerThread-y be\u017eia mimo \u017eivotn\u00e9ho cyklu aktivity, tak\u017ee sa nesmie zabudn\u00fa\u0165 na ich spr\u00e1vne ukon\u010denie ak u\u017e niesu potrebn\u00e9, inak m\u00f4\u017ee doch\u00e1dza\u0165 k nechcen\u00e9mu vytv\u00e1raniu nov\u00fdch vl\u00e1kien. Toto je obzvl\u00e1\u0161\u0165 nebezpe\u010dn\u00e9, ak sa pou\u017e\u00edvaj\u00fa pre dlhodobo prebiehaj\u00face procesy. Neexistuje \u017eiadny podobn\u00fd mechanizmus na sp\u00e4tn\u00e9 odosielanie v\u00fdsledkov do hlavn\u00e9ho vl\u00e1kna ako je tu v pr\u00edpade AsyncTask-u. To znamen\u00e1 viac k\u00f3du, ktor\u00fd je potrebn\u00e9 p\u00edsa\u0165.","title":"HandlerThread"},{"location":"#praca-s-handlerthread","text":"Pri pr\u00e1ci s HandlerThread je potrebn\u00e9 vytvori\u0165 a prepoji\u0165 z\u00e1sobn\u00edk spr\u00e1v a \u00faloh, z ktor\u00e9ho si bude HandlerThread odobera\u0165 \u00falohy pre svoju \u010dinnos\u0165. T\u00e1to fronta je tvoren\u00e1 objektom Handler . HandlerThread handlerThread = new HandlerThread ( \"MyHandlerThread\" ); handlerThread . start (); Looper looper = handlerThread . getLooper (); Handler handler = new Handler ( looper ); Ako prv\u00e9 vytvor\u00edme nov\u00fd HandlerThread a pomenujeme ho. Potom spust\u00edme HandlerThread, z\u00edskame Looper pre HandlerThread a odovzd\u00e1me ho Handler-ovi","title":"Pr\u00e1ca s HandlerThread"},{"location":"#zasobnik-sprav-handler","text":"Vl\u00e1kno, ktor\u00e9 chce komunikova\u0165 s hlavn\u00fdm vl\u00e1knom alebo HandlerThread vl\u00e1knom si mus\u00ed vy\u017eiada\u0165 token za pomoci met\u00f3dy obtainMessage() . Po obdr\u017ean\u00ed tokenu m\u00f4\u017ee vl\u00e1kno naplni\u0165 d\u00e1ta do token objektu a za pomoci met\u00f3dy sendMessage() tento token zaradi\u0165 do z\u00e1sobn\u00edka spr\u00e1v. Vytvoren\u00fd Handler vol\u00e1 met\u00f3du handleMessage() po prijat\u00ed novej spr\u00e1vy. Spr\u00e1va odobrat\u00e1 zo z\u00e1sobn\u00edka spr\u00e1v obsahuje d\u00e1ta alebo po\u017eiadavku na vykonanie Runnable objektu vlo\u017en\u00e9ho pomocou met\u00f3du post() . Mechanizmus odovzdania Runnable objektu alebo spr\u00e1vy. Runnable objekt predstavuje pracovn\u00fd blok, ktor\u00fd sa m\u00e1 vykona\u0165 na vl\u00e1kne pr\u00edjemcu (pracovn\u00e9 vl\u00e1kno alebo hlavn\u00e9 vl\u00e1kno). Inicializ\u00e1cia vl\u00e1kna a handlera v hlavnom vl\u00e1kne //Inicializ\u00e1cia handler vl\u00e1kna final HandlerThread backJob = new HandlerThread ( \"Vlakno casovaca\" ); backJob . start (); //Spustenie vl\u00e1kna //Pridelenie looper slu\u010dky do Handler triedy Looper mLooper = backJob . getLooper (); mHandler = new MyHandler ( mLooper ); Vytvorenie triedy handlera // Handler pre HandlerThread class MyHandler extends Handler { public MyHandler ( Looper myLooper ) { super ( myLooper ); } //Obsluha prijatia spr\u00e1vy public void handleMessage ( Message msg ) { } } Uk\u00e1\u017eka odosielania spr\u00e1vy Message msg = mHandler . obtainMessage ( 1 , data ); mHandler . sendMessage ( msg );","title":"Z\u00e1sobn\u00edk spr\u00e1v - Handler"},{"location":"#threadpool","text":"V praxi existuj\u00fa ur\u010dit\u00e9 druhy pr\u00e1ce, ktor\u00e9 mo\u017eno efekt\u00edvne paralelizova\u0165. Jednou z tak\u00fdchto \u00faloh je napr\u00edklad filtr\u00e1cia obr\u00e1zku po blokoch 8x8 s rozl\u00ed\u0161en\u00edm obr\u00e1zku 8 megapixelov. Tak\u00fdto druhu \u00falohy je v dne\u0161n\u00fdch viacjadrov\u00fdch zariadenia vhodn\u00e9 paralelizova\u0165 s viacer\u00fdmi vl\u00e1knami. Paralelizova\u0165 dan\u00fa \u00falohu by predstavovala pre program\u00e1tora \u00falohu manu\u00e1lne balansova\u0165 z\u00e1\u0165a\u017ee vytvoren\u00fdch vl\u00e1kien, tomuto sa ale chceme vyhn\u00fa\u0165. ThreadPoolExecutor je pomocn\u00e1 trieda na u\u013eah\u010denie tohto procesu. T\u00e1to trieda riadi vytv\u00e1ranie skupiny vl\u00e1kien, ur\u010duje ich priority a riadi rozdelenie pr\u00e1ce medzi tieto vl\u00e1kna. Ke\u010f sa pracovn\u00e9 za\u0165a\u017eenie zvy\u0161uje, trieda Executor zv\u00e4\u010d\u0161uje po\u010det vl\u00e1kien, v opa\u010dnom pr\u00edpade, ke\u010f sa za\u0165a\u017eenie zni\u017euje tak zni\u017euje aj po\u010det vl\u00e1kien. Tak to sa deje v\u017edy s prihliadnut\u00edm aby sa prisp\u00f4sobil po\u010det spusten\u00fdch vl\u00e1kien aktu\u00e1lnemu pracovn\u00e9mu za\u0165a\u017eeniu. T\u00e1to trieda tie\u017e pom\u00e1ha aplik\u00e1cii vytvori\u0165 optim\u00e1lny po\u010det vl\u00e1kien. Pri vytv\u00e1ran\u00ed ThreadPoolExecutor objektu aplik\u00e1cia nastav\u00ed minim\u00e1lny a maxim\u00e1lny po\u010det vl\u00e1kien. Preto\u017ee pracovn\u00e9 za\u0165a\u017eenie je dan\u00e9, trieda ThreadPoolExecutor vezme do \u00favahy definovan\u00e9 hodnoty minim\u00e1lneho a maxim\u00e1lneho po\u010dtu vl\u00e1kien a zv\u00e1\u017ei mno\u017estvo nevybavenej pr\u00e1ce, ktor\u00fa treba vykona\u0165. Na z\u00e1klade t\u00fdchto faktorov ThreadPoolExecutor rozhoduje o tom, ko\u013eko vl\u00e1kien by malo by\u0165 v danom okamihu na\u017eive.","title":"ThreadPool"},{"location":"#vlakna-a-zmeny-konfiguracierestart-aplikacie","text":"Pri re\u0161tarte aktivity z d\u00f4vodu zmeny konfigur\u00e1cie (napr. oto\u010denie displeja) treba ma\u0165 na zreteli: aktivita, ktor\u00e1 si vytvorila vl\u00e1kno na spracovanie \u00faloh na pozad\u00ed napr. AsyncTask , mus\u00ed pri re\u0161tarte bu\u010f t\u00fato \u00falohu zru\u0161i\u0165 alebo o\u0161etri\u0165 aby dan\u00e9 vl\u00e1kno o re\u0161tarte bolo informovan\u00e9. Vo vl\u00e1kne be\u017eiacom na pozad\u00ed treba rozv\u00e1\u017ene pou\u017e\u00edva\u0165 met\u00f3du getActivity(), ktor\u00e1 m\u00f4\u017ee po\u010das re\u0161tartu aplik\u00e1cie vr\u00e1ti\u0165 in\u0161tanciu u\u017e neexistuj\u00facej aktivity.","title":"Vl\u00e1kna a zmeny konfigur\u00e1cie(re\u0161tart aplik\u00e1cie)"},{"location":"#dlhotrvajuce-ulohy-na-pozadi","text":"V predch\u00e1dzaj\u00faci \u010dasti sme sa venovali vl\u00e1knam, ktor\u00e9 sl\u00fa\u017eia na odbremenenia hlavn\u00e9ho vl\u00e1kna od pr\u00e1ce, ktor\u00e1 m\u00f4\u017ee dan\u00e9 vl\u00e1kno vy\u0165a\u017ei\u0165 a sp\u00f4sobi\u0165 tzv. zmrznutie aplik\u00e1cie. Pr\u00e1ca, ktor\u00e1 sa vykon\u00e1va na pracovn\u00fdch vl\u00e1knach ma charakter kr\u00e1tkodobej \u00falohy, ktor\u00e1 je priamo sp\u00e4t\u00e1 s aplik\u00e1ciu be\u017eiacou na popred\u00ed s ktorou u\u017e\u00edvate\u013e akt\u00edvne pracuje. Aplik\u00e1cie m\u00f4\u017eu vy\u017eadova\u0165 spustenie niektor\u00fdch \u00faloh, aj ke\u010f pou\u017e\u00edvate\u013e aplik\u00e1ciu akt\u00edvne nepou\u017e\u00edva, napr\u00edklad pravideln\u00fa synchroniz\u00e1ciu so serverom alebo pravideln\u00e9 na\u010d\u00edtavanie nov\u00e9ho obsahu v aplik\u00e1cii. Aplik\u00e1cie m\u00f4\u017eu tie\u017e vy\u017eadova\u0165, aby sa slu\u017eby spustili okam\u017eite po dokon\u010den\u00ed \u00falohy, aj ke\u010f pou\u017e\u00edvate\u013e prestal akt\u00edvne aplik\u00e1ciou pou\u017e\u00edva\u0165. T\u00e1to kapitola m\u00e1 zacie\u013e napom\u00f4c\u0165 zisti\u0165, ktor\u00e9 rie\u0161enie najlep\u0161ie vyhovuje va\u0161im potreb\u00e1m v t\u00fdchto pr\u00edpadoch pou\u017eitia.","title":"Dlhotrvaj\u00face \u00falohy na pozad\u00ed "},{"location":"#obmedzenia-android-os-ktore-ovplyvnuju-vykonavanie-uloh-na-pozadi","text":"Aby sa maximalizovala v\u00fddr\u017e bat\u00e9rie a vyn\u00fatilo sa dobr\u00e9 spr\u00e1vanie aplik\u00e1cie, Android obmedzuje pr\u00e1cu na pozad\u00ed, ke\u010f pou\u017e\u00edvate\u013e akt\u00edvne nevyu\u017e\u00edva aplik\u00e1ciu (notifik\u00e1cia na slu\u017ebu). Android 6.0 (API \u00farove\u0148 23) predstavil re\u017eim Doze a pohotovostn\u00fd re\u017eim aplik\u00e1cie . Re\u017eim Doze obmedzuje spr\u00e1vanie aplik\u00e1cie, ke\u010f je obrazovka vypnut\u00e1 a zariadenie je nehybn\u00e9 (le\u017e\u00ed na stole bez pohnutia). Pohotovostn\u00fd re\u017eim stavia nepou\u017e\u00edvan\u00e9 aplik\u00e1cie do \u0161peci\u00e1lneho stavu, ktor\u00fd obmedzuje ich pr\u00edstup k sieti, \u00falohy a synchroniz\u00e1ciu. Android 7.0 (API \u00farove\u0148 24) obmedzoval implicitn\u00e9 vysielanie a predstavil Doze-on-the-Go . Android 8.0 (API \u00farove\u0148 26) \u010falej obmedzoval chovanie na pozad\u00ed , napr\u00edklad z\u00edskavanie polohy na pozad\u00ed a uvo\u013e\u0148ovanie wakelokov z pam\u00e4ti. Android 9 (API \u00farove\u0148 28) predstavil segmenty pohotovostn\u00e9ho re\u017eimu pre aplik\u00e1cie , v ktor\u00fdch s\u00fa \u017eiadosti o prostriedky na zdroje dynamicky uprednost\u0148ovan\u00e9 na z\u00e1klade vzorov pou\u017e\u00edvania aplik\u00e1ci\u00ed.","title":"Obmedzenia Android OS, ktor\u00e9 ovplyv\u0148uj\u00fa vykon\u00e1vanie \u00faloh na pozad\u00ed"},{"location":"#workmanager","text":"Ur\u010den\u00e9 pre: nez\u00e1visl\u00e1 \u00faloha s predpokladom, \u017ee m\u00e1 be\u017ea\u0165 aj ke\u010f aplik\u00e1cia alebo zariadenia sa re\u0161tartuje spustenie \u00falohy pri splnen\u00ed syst\u00e9mov\u00fdch po\u017eiadaviek(napr. dostupn\u00e1 sie\u0165, bat\u00e9ria je nabit\u00e1) s\u00fa\u010das\u0165 AndroidX sp\u00e4tn\u00e1 kompatibilita a\u017e na API level 14 WorkManager tie\u017e podporuje sp\u00fa\u0161\u0165anie \u00faloh ako slu\u017ebu v popred\u00ed(Foreground service), \u010do je ide\u00e1lne, ke\u010f \u00faloha by nemala by\u0165 preru\u0161en\u00e1.","title":"WorkManager "},{"location":"#foreground-services-sluzba-v-popredi","text":"Pre pr\u00e1cu iniciovan\u00fa pou\u017e\u00edvate\u013eom, ktor\u00e1 mus\u00ed by\u0165 spusten\u00e1 okam\u017eite a mus\u00ed by\u0165 vykonan\u00e1 a\u017e do ukon\u010denia. Pou\u017e\u00edvanie slu\u017eby foreground service povie syst\u00e9mu, \u017ee aplik\u00e1cia rob\u00ed nie\u010do d\u00f4le\u017eit\u00e9 a nemala by by\u0165 zabit\u00e1. Slu\u017eby popredia s\u00fa pre pou\u017e\u00edvate\u013eov vidite\u013en\u00e9 prostredn\u00edctvom ozn\u00e1menia(notofication), ktor\u00e9 sa ned\u00e1 zru\u0161i\u0165","title":"Foreground services / Slu\u017eba v popred\u00ed "},{"location":"#alarmmanager","text":"Ak potrebujete spusti\u0165 \u00falohu v presnom \u010dase, pou\u017eite AlarmManager. AlarmManager v pr\u00edpade potreby spust\u00ed va\u0161u aplik\u00e1ciu na vykonanie \u00falohy v \u010dase, ktor\u00fd ur\u010d\u00edte. Ak v\u0161ak va\u0161a pr\u00e1ca nemus\u00ed prebieha\u0165 v presnom \u010dase, WorkManager je lep\u0161ou mo\u017enos\u0165ou. WorkManager dok\u00e1\u017ee lep\u0161ie vyv\u00e1\u017ei\u0165 syst\u00e9mov\u00e9 prostriedky. Napr\u00edklad, ak potrebujete spusti\u0165 \u00falohu ka\u017ed\u00fa hodinu, ale nie potrebn\u00e9 \u00faplne presn\u00e9 na\u010dasovanie, mali by ste pou\u017ei\u0165 WorkManagerna a nastavi\u0165 opakuj\u00facu sa \u00falohu.","title":"AlarmManager "},{"location":"#downloadmanager","text":"stiahnutie ve\u013ek\u00fdch s\u00faborov alebo ve\u013ea s\u00faborov cez HTTP, zv\u00e1\u017ete pou\u017eitie DownloadManager stiahnutie vykon\u00e1 na pozad\u00ed, pri\u010dom sa postar\u00e1 o interakcie s HTTP opakovan\u00e9 stiahnutie pri zlyhaniach alebo pri zmen\u00e1ch pripojenia a re\u0161tartovan\u00ed syst\u00e9mu","title":"DownloadManager "},{"location":"senzory/","text":"Senzory \u00b6 T\u00e1to predn\u00e1\u0161ka sa zaober\u00e1 t\u00e9mou vstavan\u00fdch senzorov v syst\u00e9me Android ale aj lokaliza\u010dn\u00fdm podsyst\u00e9mom Location API. \u00davod do senzorov \u00b6 V\u00e4\u010d\u0161ina dne\u0161n\u00fdch Android zariaden\u00ed obsahuje vstavan\u00e9 senzory, ktor\u00e9 umo\u017e\u0148uj\u00fa mera\u0165 zr\u00fdchlenie, nato\u010denie zariadenia a mnoho \u010fal\u0161\u00edch fyzik\u00e1lnych veli\u010d\u00edn. Tieto senzory s\u00fa schopn\u00e9 poskytn\u00fa\u0165 surov\u00e9 d\u00e1ta s ve\u013ekou presnos\u0165ou a vo ve\u013ekom rozsahu a s\u00fa u\u017eito\u010dn\u00e9, ak chceme monitorova\u0165 pohyb alebo polohu zariadenia v trojrozmernom priestore alebo ak chceme monitorova\u0165 zmeny okolit\u00e9ho prostredia v bl\u00edzkosti zariadenia. Napr\u00edklad hra m\u00f4\u017ee sledova\u0165 \u00fadaje z akcelerometra a identifikova\u0165 zlo\u017eit\u00e9 gest\u00e1 a pohyby pou\u017e\u00edvate\u013ea, ako napr\u00edklad naklonenie, chvenie, rot\u00e1cia a pod. Podobne aj aplik\u00e1cia na po\u010dasie m\u00f4\u017ee na v\u00fdpo\u010det a ur\u010denie rosn\u00e9ho bodu pou\u017ei\u0165 sn\u00edma\u010d teploty a vlhkosti alebo navig\u00e1cia m\u00f4\u017ee vyu\u017ei\u0165 d\u00e1ta z trojosov\u00e9ho magnetometra, ktor\u00fd sn\u00edma geomagnetick\u00e9 pole Zeme a d\u00e1ta z akcelerometra na spresnenie navig\u00e1cie. Platforma Android podporuje tri kateg\u00f3rie senzorov: Pohybov\u00e9 senzory Tieto senzory meraj\u00fa fyzik\u00e1lne veli\u010diny ako: zr\u00fdchlenie a rota\u010dn\u00e9 sily pozd\u013a\u017e troch os\u00ed. Do tejto kateg\u00f3rie patria akcelerometre, gravita\u010dn\u00e9 senzory, gyroskopy a senzory nato\u010denia. Senzory prostredia Tieto senzory meraj\u00fa r\u00f4zne parametre prostredia, ako je teplota a tlak okolit\u00e9ho vzduchu, osvetlenie a vlhkos\u0165. T\u00e1to kateg\u00f3ria zah\u0155\u0148a barometre, fotometre (meranie intenzity svetla) a teplomery. Polohov\u00e9 senzory Tieto senzory meraj\u00fa fyzick\u00fa polohu zariadenia. T\u00e1to kateg\u00f3ria zah\u0155\u0148a senzory orient\u00e1cie a magnetometre. V syst\u00e9me Android m\u00f4\u017eeme senzory e\u0161te rozdeli\u0165 pod\u013ea toho, \u010di \u00fadaje poch\u00e1dzaj\u00fa priamo z fyzick\u00e9ho senzora alebo ide o softv\u00e9rov\u00fd senzor, ktor\u00fd poskytuje u\u017e predspracovan\u00e9 d\u00e1ta. Predspracovanie d\u00e1t m\u00f4\u017ee zah\u0155\u0148a\u0165 napr\u00edklad: filtrovanie d\u00e1t, f\u00faziu d\u00e1t z r\u00f4znych senzorov alebo transformovanie d\u00e1t do inej formy. Hardv\u00e9rov\u00e9 senzory odvodzuj\u00fa \u00fadaje priamym meran\u00edm \u0161pecifick\u00fdch vlastnost\u00ed prostredia. Medzi hardv\u00e9rov\u00e9 senzory rad\u00edme: Mikrof\u00f3n Kamera Teplota Poloha (GPS) Accelerometer Proximity Tlak Svetelnos\u0165 Medzi softv\u00e9rov\u00e9 rad\u00edme: Gravit\u00e1cia Line\u00e1rna akceler\u00e1cia Orient\u00e1cia Android poskytuje rozsiahly framework na pr\u00edstup k senzorom. Tento framework poskytuje nieko\u013eko tried a rozhran\u00ed, ktor\u00e9 m\u00f4\u017eeme vyu\u017ei\u0165 napr\u00edklad na: Ur\u010di\u0165 ak\u00e9 senzory s\u00fa k dispoz\u00edcii na danom zariaden\u00ed. Ka\u017ed\u00fd v\u00fdrobca zariaden\u00ed si s\u00e1m ur\u010duje ak\u00fdm senzormi osad\u00ed svoje zariadenia. Nie je to \u0161tandardizovan\u00e9. Ur\u010di\u0165 vlastnosti jednotliv\u00fdch sn\u00edma\u010dov, napr\u00edklad maxim\u00e1lny dosah, v\u00fdrobca, po\u017eiadavky na nap\u00e1janie a rozl\u00ed\u0161enie. Z\u00edska\u0165 surov\u00e9 \u00fadaje zo sn\u00edma\u010da a definujte minim\u00e1lnu vzorkovaciu frekvenciu (ako \u010dasto dost\u00e1vame d\u00e1ta ). Slov\u00ed\u010dko minim\u00e1lne je pou\u017eit\u00e9 z toho d\u00f4vodu, \u017ee senzory s\u00fa zdielan\u00e9 medzi v\u0161etk\u00fdmi aplik\u00e1ciami zariadenia. V pr\u00edpade ak niektor\u00e1 aplik\u00e1cia po\u017eaduje vy\u0161\u0161iu vzorkovaciu frekvenciu ako posta\u010dovala pre na\u0161u aplik\u00e1ciu, tak vzorkovacia frekvencia sa zv\u00fd\u0161i, \u010do ovplyvni aj vzorkovanie pre na\u0161u aplik\u00e1ciu. Hodnota vzorkovacej frekvencie ale nem\u00f4\u017ee klesn\u00fa\u0165 pod nami nastaven\u00e9 minimum. Zaregistrovanie a zru\u0161enie registr\u00e1cie na odoberanie udalost\u00ed od senzora. Pr\u00edklady udalost\u00ed, na ktor\u00e9 sa m\u00f4\u017eeme registrova\u0165 s\u00fa: nov\u00e1 hodnota, zmena presnosti, zmena citlivosti a pod. M\u00e1lo zariaden\u00ed so syst\u00e9mom Android m\u00e1 ka\u017ed\u00fd typ senzora. Napr\u00edklad v\u00e4\u010d\u0161ina mobiln\u00fdch telef\u00f3nov a tabletov m\u00e1 akcelerometer a magnetometer, ale menej pr\u00edstrojov m\u00e1 barometre alebo teplomery. Zariadenie m\u00f4\u017ee ma\u0165 tie\u017e viac ako jeden senzor dan\u00e9ho typu. Napr\u00edklad zariadenie m\u00f4\u017ee ma\u0165 dva sn\u00edma\u010de gravit\u00e1cie, z ktor\u00fdch ka\u017ed\u00fd m\u00e1 in\u00fd rozsah. senzor typ popis Be\u017en\u00e9 pou\u017eitia TYPE_ACCELEROMETER hardv\u00e9r Zmeria silu zr\u00fdchlenia v m/s^2 m/s^2 , ktor\u00e1 p\u00f4sob\u00ed na zariadenie vo v\u0161etk\u00fdch troch os\u00e1ch (x, y a z), vr\u00e1tane gravita\u010dnej sily. Detekcia pohybu (chvenie, n\u00e1klon at\u010f.). TYPE_AMBIENT_TEMPERATURE hardv\u00e9r Zmeria teplotu okolia v stup\u0148och Celzia (\u00b0C). Pozri pozn\u00e1mku ni\u017e\u0161ie. Monitorovanie teploty vzduchu. TYPE_GRAVITY Softv\u00e9r alebo hardv\u00e9r Zmeria gravita\u010dn\u00fa silu v m/s^2 m/s^2 , ktor\u00e1 p\u00f4sob\u00ed na zariadenie na v\u0161etk\u00fdch troch fyzick\u00fdch os\u00e1ch (x, y, z). Detekcia pohybu (chvenie, n\u00e1klon at\u010f.). TYPE_GYROSCOPE hardv\u00e9r Zmeria r\u00fdchlos\u0165 rot\u00e1cie zariadenia v rad / s okolo ka\u017edej z troch fyzick\u00fdch os\u00ed (x, y a z). Detekcia rot\u00e1cie (rot\u00e1cia, oto\u010denie at\u010f.). TYPE_LIGHT hardv\u00e9r Meria \u00farove\u0148 okolit\u00e9ho svetla (osvetlenie) v lx . Ovl\u00e1danie jasu obrazovky. TYPE_LINEAR_ACCELERATION Softv\u00e9r alebo hardv\u00e9r Zmeria silu zr\u00fdchlenia v m/s^2 m/s^2 , ktor\u00e1 p\u00f4sob\u00ed na zariadenie vo v\u0161etk\u00fdch troch os\u00e1ch (x, y a z), s v\u00fdnimkou gravita\u010dnej sily. Monitorovanie zr\u00fdchlenia pozd\u013a\u017e jednej osi. TYPE_MAGNETIC_FIELD hardv\u00e9r Zmeria sa okolit\u00e9 geomagnetick\u00e9 pole pre v\u0161etky tri fyzik\u00e1lne osi (x, y, z) v \u03bcT. Vytvorenie kompasu. TYPE_ORIENTATION softv\u00e9r Zmeria stupne nato\u010denia, ktor\u00e9 zariadenie vykon\u00e1 okolo v\u0161etk\u00fdch troch fyzick\u00fdch os\u00ed (x, y, z). Od API \u00farovne 3 m\u00f4\u017eete z\u00edska\u0165 maticu n\u00e1klonu a rota\u010dn\u00fa maticu pre zariadenie pomocou gravita\u010dn\u00e9ho senzora a senzora geomagnetick\u00e9ho po\u013ea v spojen\u00ed s touto met\u00f3dou getRotationMatrix() . Ur\u010denie polohy zariadenia. TYPE_PRESSURE hardv\u00e9r Zmeria tlak okolit\u00e9ho vzduchu v hPa alebo mbar. Monitorovanie zmien tlaku vzduchu. TYPE_PROXIMITY hardv\u00e9r Zmeria bl\u00edzkos\u0165 objektu v cm vzh\u013eadom na obrazovku zariadenia. Tento senzor sa zvy\u010dajne pou\u017e\u00edva na ur\u010denie, \u010di je sl\u00fachadlo dr\u017ean\u00e9 pri uchu osoby. Poloha telef\u00f3nu po\u010das hovoru. TYPE_RELATIVE_HUMIDITY hardv\u00e9r Zmeria relat\u00edvnu vlhkos\u0165 okolia v percent\u00e1ch (%). Monitorovanie rosn\u00e9ho bodu, absol\u00fatnej a relat\u00edvnej vlhkosti. TYPE_ROTATION_VECTOR Softv\u00e9r alebo hardv\u00e9r Zmeria orient\u00e1ciu zariadenia poskytnut\u00edm troch prvkov rota\u010dn\u00e9ho vektora zariadenia. Detekcia pohybu a detekcia rot\u00e1cie. TYPE_TEMPERATURE hardv\u00e9r Zmeria teplotu zariadenia v stup\u0148och Celzia (\u00b0C). T\u00e1to implement\u00e1cia senzora sa medzi zariadeniami l\u00ed\u0161i a tento senzor bol nahraden\u00fd TYPE_AMBIENT_TEMPERATURE senzorom v API Level 14 Monitorovanie teploty. Framework \u00b6 K senzorom m\u00f4\u017eete pristupova\u0165 a z\u00edskava\u0165 nespracovan\u00e9 t.j. surov\u00e9 d\u00e1ta pomocou frameworku ktor\u00fd je s\u00fa\u010das\u0165ou android.hardware bal\u00edka a obsahuje nasleduj\u00face triedy a rozhrania: SensorManager T\u00fato triedu m\u00f4\u017eete pou\u017ei\u0165 na vytvorenie in\u0161tancie slu\u017eby sp\u00e4tej so senzormi. T\u00e1to trieda poskytuje r\u00f4zne met\u00f3dy pre pr\u00edstup a zoznam senzorov, registr\u00e1ciu a zru\u0161enie registr\u00e1cie prij\u00edmania udalost\u00ed senzorov. T\u00e1to trieda tie\u017e poskytuje nieko\u013eko kon\u0161t\u00e1nt, ktor\u00e9 sa pou\u017e\u00edvaj\u00fa na definovanie presnosti senzora, nastavenie r\u00fdchlosti z\u00edskavania \u00fadajov (vzorkovacia frekvencia) a kalibr\u00e1ciu senzorov. Sensor T\u00fato triedu m\u00f4\u017eete pou\u017ei\u0165 na vytvorenie in\u0161tancie konkr\u00e9tneho senzora. T\u00e1to trieda poskytuje r\u00f4zne met\u00f3dy, ktor\u00e9 v\u00e1m umo\u017e\u0148uj\u00fa ur\u010di\u0165 schopnosti senzora. SensorEvent Syst\u00e9m pou\u017e\u00edva t\u00fato triedu na vytvorenie objektu udalosti senzora, ktor\u00fd poskytuje inform\u00e1cie o udalosti ktor\u00fa emitoval senzor. Objekt SenzorEvent obsahuje nasleduj\u00face inform\u00e1cie: prvotn\u00e9 \u00fadaje senzora, typ senzora, ktor\u00fd generoval udalos\u0165, presnos\u0165 \u00fadajov a \u010dasov\u00e9 raz\u00edtko udalosti. SensorEventListener Toto rozhranie m\u00f4\u017eete pou\u017ei\u0165 na vytvorenie dvoch met\u00f3d sp\u00e4tn\u00e9ho volania, ktor\u00e9 prij\u00edmaj\u00fa ozn\u00e1menia (udalosti senzora) pri zmene hodn\u00f4t senzora alebo pri zmene presnosti senzora. Identifikovanie senzorov a ich vlastnosti \u00b6 Z\u00edskanie in\u0161tancie triedy SensorManager Tento krok predstavuje vstupn\u00fd bod, ktor\u00fd je nutn\u00e9 spravi\u0165, aby sme vedeli pristupova\u0165 k senzor framework-u. private SensorManager mSensorManager ; ... mSensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); Pomocou in\u0161tancie triedy SensorManager si vieme vy\u017eiada\u0165 zoznam dostupn\u00fdch senzorov. Vy\u017eiadame si bu\u010f cel\u00fd zoznam alebo iba ur\u010dit\u00fa kateg\u00f3riu: TYPE_ALL - v\u0161etky dostupn\u00e9 senzory TYPE_GYROSCOPE , TYPE_LINEAR_ACCELERATION , TYPE_GRAVITY` List < Sensor > deviceSensors = mSensorManager . getSensorList ( Sensor . TYPE_ALL ); Overenie \u010di dan\u00fd senzor existuje na zariaden\u00ed pomocou getDefaultSensor() . Ak dan\u00fd senzor v zariaden\u00ed existuje, tak vr\u00e1ti in\u0161tanciu objektu Senzor . Ak zariadenie obsahuje viac ako jeden senzor dan\u00e9ho typu, jeden zo senzorov mus\u00ed by\u0165 ozna\u010den\u00fd ako predvolen\u00fd senzor. Ak pre dan\u00fd typ senzora neexistuje predvolen\u00fd senzor, volanie met\u00f3dy vr\u00e1ti hodnotu null , \u010do znamen\u00e1, \u017ee tak\u00fdto typ senzora nie je v zariaden\u00ed osaden\u00fd. private SensorManager mSensorManager ; ... mSensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); if ( mSensorManager . getDefaultSensor ( Sensor . TYPE_MAGNETIC_FIELD ) != null ){ // Success! There's a magnetometer. } else { // Failure! No magnetometer. } Pomocou z\u00edskan\u00e9ho objektu Senzor vieme ur\u010dit aj \u010fal\u0161ie vlastnosti konkr\u00e9tneho senzora tak, \u017ee zavol\u00e1me pr\u00edslu\u0161n\u00e9 met\u00f3dy napr: Verejn\u00e9 met\u00f3dy int getMaxDelay() float getMaximumRange() int getMinDelay() String getName() float getPower() int getReportingMode() float getResolution() String getStringType() int getType() String getVendor() int getVersion() Vzorkovacia frekvencia Met\u00f3da getMinDelay() je u\u017eito\u010dn\u00e1 ak chceme z\u00edska\u0165 inform\u00e1ciu ak\u00e1 je maxim\u00e1lna vzorkovacia frekvencia. T\u00e1to premenn\u00e1 vracia minim\u00e1lnu peri\u00f3du vzorkovania v mikrosekund\u00e1ch na v\u00fdpo\u010det vzorkovacej frekvencie pou\u017eije zn\u00e1my vzorec: $$ f_{vzorkovacia} = \\frac{1}{getMinDelay()\\times10^6}[Hz] $$ Ak met\u00f3da getMinDelay() vr\u00e1ti 0 tak v tomto pr\u00edpade senzor vyvol\u00e1 udalos\u0165 iba pri zmene meranej veli\u010diny Komunik\u00e1cia so senzormi \u00b6 Komunik\u00e1cia so senzorom prebieha asynchr\u00f3nnym sp\u00f4sobom. Senzory Androidu s\u00fa riaden\u00e9 extern\u00fdmi slu\u017ebami a komunikuj\u00fa na z\u00e1klade odosielania udalosti. Aplik\u00e1cia sa mus\u00ed zaregistrova\u0165 na pr\u00edjem t\u00fdchto udalost\u00ed implementovan\u00edm rozhrania SensorEventListener . V rozhran\u00ed SensorEventListener existuj\u00fa dve met\u00f3dy sp\u00e4tn\u00e9ho volania tzv callback met\u00f3dy onAccuracyChanged() a onSensorChanged() . Android vol\u00e1 tieto met\u00f3dy v\u017edy, ke\u010f nastane t\u00e1to situ\u00e1cia: Ak sa zmen\u00ed presnos\u0165 senzora syst\u00e9m vol\u00e1 met\u00f3du onAccuracyChanged() a poskytne referenciu na Sensor objekt, ktor\u00e9ho sa dan\u00e1 situ\u00e1cia t\u00fdka. Ak senzor na\u010d\u00edta nov\u00fa hodnotu syst\u00e9m vol\u00e1 met\u00f3du onSensorChanged() a poskytne referenciu na SensorEvent . Tento objekt obsahuje nasleduj\u00face atrib\u00faty: Atrib\u00faty public int accuracy Presnos\u0165 tejto udalosti. public Sensor sensor Senzor, ktor\u00fd generoval t\u00fato udalos\u0165. public long timestamp \u010cas v nanosekund\u00e1ch, v ktorom sa udalos\u0165 stala public final float[] values D\u013a\u017eka a obsah po\u013ea values z\u00e1vis\u00ed od toho, pre ktor\u00fd typ senzoru bol dan\u00fd objekt vytvoren\u00fd. Atrib\u00fat SensorEvent.values D\u00f4le\u017eit\u00e9 je si uvedomi\u0165, \u017ee objekt SensorEvent sa pou\u017e\u00edva pre v\u0161etky typy senzorov, ktor\u00e9 poskytuj\u00fa r\u00f4zne d\u00e1ta a preto na pole hodn\u00f4t values sa treba pozrie\u0165 v\u017edy v kontexte konkr\u00e9tneho senzora, ktor\u00fd ur\u010duje \u010do ulo\u017e\u00ed do dan\u00e9ho po\u013ea. Zaregistrovania odberu udalost\u00ed od senzora @Override protected void onResume () { super . onResume (); mSensorManager . registerListener ( this , mLight , SensorManager . SENSOR_DELAY_NORMAL ); } Pri registr\u00e1cii sme definovali pomocou kon\u0161tanty SENSOR_DELAY_NORMAL , minim\u00e1lnu vzorkovaciu frekvenciu alebo inak povedan\u00e9 maxim\u00e1lny \u010das medzi vzorkami. Pre ka\u017ed\u00fd typ aplik\u00e1cie je vhodne vybra\u0165 t\u00fato hodnota tak, aby zodpovedala po\u017eiadavk\u00e1m, ktor\u00e9 s\u00fa kladen\u00e9 na aplik\u00e1ciu. Z\u00e1rove\u0148 v\u0161ak treba bra\u0165 do \u00favahy v\u00fdpo\u010dtov\u00e9 a s t\u00fdm sp\u00e4t\u00e9 aj energetick\u00e9 n\u00e1roky, ktor\u00e9 vypl\u00fdvaj\u00fa z pou\u017eitia senzora a nastavenia ve\u013emi vysokej vzorkovacej frekvencie. Exituj\u00fa tieto kon\u0161tanty, ktor\u00e9 maj\u00fa napom\u00f4c\u0165 vybra\u0165 vhodn\u00fa vzorkovaciu frekvenciu: u\u017e spomenut\u00e1 SENSOR_DELAY_NORMAL a potom SENSOR_DELAY_GAME , SENSOR_DELAY_UI , alebo \u0161pecifick\u00e1 hodnota zadan\u00e1 v mikrosekund\u00e1ch. Ako u\u017e bolo spomenut\u00e9 v predch\u00e1dzaj\u00facich \u010dastiach, vzorkovacia frekvencia sa m\u00f4\u017ee meni\u0165 vzh\u013eadom na to, \u017ee senzory s\u00fa zdielan\u00e9 medzi v\u0161etk\u00fdmi aplik\u00e1ciami. Ak in\u00e1 aplik\u00e1cia potrebuje vy\u0161\u0161iu vzorkovaciu frekvenciu, tak aj na\u0161a aplik\u00e1cia bude dost\u00e1va\u0165 \u00fadaju \u010dastej\u0161ie. Neexistuje met\u00f3da pomocou ktorej by sa dala ur\u010di\u0165 aktu\u00e1lna vzorkovacia frekvencia, jedin\u00e1 mo\u017enos\u0165 je ur\u010di\u0165 ju nepriamo pomocou \u010dasovej zn\u00e1mky, ktor\u00e1 je obsiahnut\u00e1 v objekte SensorEvent . Zru\u0161enie registr\u00e1cie odberu udalost\u00ed od senzora @Override protected void onPause () { super . onPause (); mSensorManager . unregisterListener ( this ); } \u017divotn\u00fd cyklus Pri pr\u00e1ci so senzormi nesmieme zabudn\u00fa\u0165 na \u017eivotn\u00fd cyklus aplik\u00e1cie a preto registrovanie a odregistrovanie vykon\u00e1vame v met\u00f3dach \u017eivotn\u00e9ho cyklu onResume , onPause tak aby sme zbyto\u010dne nepou\u017e\u00edvali senzory, ktor\u00e9 u\u017e nepotrebujeme (zni\u017eovanie spotreby). Syst\u00e9m senzory nevyp\u00edna automaticky! Komplexn\u00fd pr\u00edklad pou\u017eitia Frameworku na pr\u00e1cu so senzormi public class SensorActivity extends Activity implements SensorEventListener { private SensorManager sensorManager ; private Sensor mLight ; @Override public final void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . main ); sensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); mLight = sensorManager . getDefaultSensor ( Sensor . TYPE_LIGHT ); } @Override public final void onAccuracyChanged ( Sensor sensor , int accuracy ) { // Do something here if sensor accuracy changes. } @Override public final void onSensorChanged ( SensorEvent event ) { // The light sensor returns a single value. // Many sensors return 3 values, one for each axis. float lux = event . values [ 0 ] ; // Do something with this sensor value. } @Override protected void onResume () { super . onResume (); sensorManager . registerListener ( this , mLight , SensorManager . SENSOR_DELAY_NORMAL ); } @Override protected void onPause () { super . onPause (); sensorManager . unregisterListener ( this ); } } Vysporiadanie sa s r\u00f4znorodos\u0165ou Android zariaden\u00ed \u00b6 Na zistenie pr\u00edtomnosti dan\u00e9ho senzora v zariaden\u00ed m\u00e1me dve komplement\u00e1rne mo\u017enosti: Detegova\u0165 senzory za behu a pod\u013ea potreby zapn\u00fa\u0165 alebo vypn\u00fa\u0165 funkcie aplik\u00e1cie. private SensorManager sensorManager ; ... sensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); if ( sensorManager . getDefaultSensor ( Sensor . TYPE_PRESSURE ) != null ){ // Success! There's a pressure sensor. } else { // Failure! No pressure sensor. } Pou\u017eitie filtrov v slu\u017ebe Google Play - zak\u00e1zanie in\u0161tal\u00e1cie aplik\u00e1cie u\u017e priamo v obchode Google Play. Tento filter sa nastavuje v AndroidManifest.xml s\u00fabore pomocou xml elementu <user-feature> <uses-feature android:name= \"android.hardware.sensor.accelerometer\" android:required= \"true\" /> android:required= ur\u010duje, \u010di dan\u00fd senzor je nevyhnutn\u00fd pre fungovanie aplik\u00e1cie. Hodnota false , dovol\u00ed aplik\u00e1ciu nain\u0161talova\u0165 aj ke\u010f dan\u00fd senzor nie je v zariaden\u00ed pr\u00edtomn\u00fd, aplik\u00e1cia sa mus\u00ed tomu prisp\u00f4sobi\u0165. Note Pre prehladnos\u0165 sa odpor\u00fa\u010da v\u0161etky pou\u017e\u00edvan\u00e9 senzory aj tie nie kritick\u00e9 pre chod aplik\u00e1cie, zap\u00edsa\u0165 do AndroidManifest.xml s\u00faboru. S\u00faradnicov\u00fd syst\u00e9m senzorov \u00b6 Pri pr\u00e1ci so senzormi, ktor\u00e9 z princ\u00edpu \u010dinnosti meraj\u00fa d\u00e1ta v osiach, Android vyu\u017e\u00edva \u0161tandardn\u00fd 3-osov\u00fd s\u00faradnicov\u00fd syst\u00e9m. Pre v\u00e4\u010d\u0161inu senzorov je s\u00faradnicov\u00fd syst\u00e9m definovan\u00fd vzh\u013eadom na obrazovku zariadenia, ke\u010f je zariadenie dr\u017ean\u00e9 v takzvanej nat\u00edvnej polohe (pozri obr\u00e1zok) . Ak je zariadenie dr\u017ean\u00e9 v tejto polohe os X je vodorovn\u00e1 a ukazuje doprava, os Y je zvisl\u00e1 a ukazuje nahor a os Z ukazuje smerom k vonkaj\u0161ej strane obrazovky. V tomto syst\u00e9me maj\u00fa s\u00faradnice za obrazovkou z\u00e1porn\u00e9 hodnoty Z. Tento s\u00faradnicov\u00fd syst\u00e9m pou\u017e\u00edvaj\u00fa nasleduj\u00face senzory: accelerometer, gravita\u010dn\u00fd senzor, gyroskop, line\u00e1rna akceler\u00e1cia, senzor geomagnetick\u00e9ho po\u013ea (kompas) S\u00faradnicov\u00fd syst\u00e9m pou\u017e\u00edvan\u00fd v Android OS D\u00f4le\u017eit\u00e9 vlastnosti: Je d\u00f4le\u017eit\u00e9 si pam\u00e4ta\u0165, \u017ee osy pri zmene orient\u00e1cie obrazovky sa nemenia/nevymie\u0148aj\u00fa- s\u00faradnicov\u00fd syst\u00e9m sa nikdy nemen\u00ed. Nat\u00edvna poloha nemus\u00ed by\u0165 v\u017edy tak\u00e1, \u017ee zariadenie je orientovan\u00e9 na v\u00fd\u0161ku. Pri mnoh\u00fdch tabletov\u00fdch zariadeniach je prirodzen\u00e1 orient\u00e1cia na \u0161\u00edrku. S\u00faradnicov\u00fd syst\u00e9m senzorov je v\u017edy zalo\u017een\u00fd na nat\u00edvnej orient\u00e1cii zariadenia. Ak aplik\u00e1cia chce vyu\u017ei\u0165 \u00fadaje senzora a transformova\u0165 na s\u00faradnice displeja, mus\u00edme pou\u017ei\u0165 met\u00f3du getRotation() na ur\u010denie rot\u00e1cie obrazovky a n\u00e1sledne pou\u017ei\u0165 met\u00f3du remapCoordinateSystem() pomocou ktorej sa mapuj\u00fa s\u00faradnice senzora na s\u00faradnice obrazovky. Note Niektor\u00e9 senzory a met\u00f3dy pou\u017e\u00edvaj\u00fa s\u00faradnicov\u00fd syst\u00e9m, ktor\u00fd je relat\u00edvny k svetov\u00e9mu referen\u010dn\u00e9mu r\u00e1mcu (na rozdiel od referen\u010dn\u00e9ho r\u00e1mca zariadenia). Tieto senzory a met\u00f3dy vracaj\u00fa \u00fadaje, ktor\u00e9 predstavuj\u00fa pohyb zariadenia alebo polohu zariadenia vzh\u013eadom na Zem. Pre viac inform\u00e1ci\u00ed vi\u010f getOrientation() met\u00f3da, getRotationMatrix() met\u00f3da, senzor orient\u00e1cie a senzor rot\u00e1cie . Osved\u010den\u00e9 postupy pre pr\u00edstup a pou\u017e\u00edvanie senzorov \u00b6 Senzory pou\u017e\u00edvajte iba ke\u010f je aplik\u00e1cia v popred\u00ed od verzie Android 9 sa aplik\u00e1cie, ktor\u00e9 be\u017eia na pozad\u00ed musia prisp\u00f4sobi\u0165 nasleduj\u00facim obmedzeniam: V pr\u00edpade nepretr\u017eit\u00e9ho vzorkovania, napr. senzor akceleromer, gyroskop, aplik\u00e1cia nedost\u00e1va nov\u00e9 d\u00e1ta. V pr\u00edpade jednor\u00e1zov\u00e9ho merania alebo udalosti o zmene meranej hodnoty, aplik\u00e1cia taktie\u017e nedost\u00e1va nov\u00e9 d\u00e1ta. Vzh\u013eadom na tieto obmedzenia je nutn\u00e9 pou\u017e\u00edva\u0165 senzor iba ke\u010f je aplik\u00e1cia v popred\u00ed alebo vyu\u017ei\u0165 ForegroundService Dba\u0165 na dodr\u017eiavanie \u017eivotn\u00e9ho cyklu aplik\u00e1cie, t.j. onPause() odhl\u00e1si\u0165 pr\u00edjem, udalost\u00ed od senzora. Testovanie senzorov pomocou Android Emulatora Neblokova\u0165 met\u00f3du onSensorChanged() Nepou\u017e\u00edvajte met\u00f3dy alebo typy sn\u00edma\u010dov, ktor\u00e9 s\u00fa ozna\u010den\u00e9 ako deprecated t.j. zastaran\u00e9 Pred pou\u017eit\u00edm senzorov treba overi\u0165 \u010di je senzor naozaj pr\u00edtomn\u00fd v zariaden\u00ed Treba spr\u00e1vne zvoli\u0165 vzorkovaciu frekvenciu - treba zabr\u00e1ni\u0165 zbyto\u010dn\u00e9mu plytvaniu CPU a energiou Ur\u010denie polohy / Satelitn\u00e1 navig\u00e1cia \u00b6 Android poskytuje lokaliz\u00e1ciu na z\u00e1klade r\u00f4znych met\u00f3d: triangul\u00e1cia na z\u00e1klade BTS, WiFi pr\u00edstupov\u00e9 body a naj\u010dastej\u0161ie GPS. Cie\u013eom tohoto rie\u0161enia je docieli\u0165, \u010do najlep\u0161ie lokaliza\u010dn\u00e9 slu\u017eby v r\u00f4znych podmienkach a obmedzeniach. Lokaliz\u00e1cia v exteri\u00e9ry, v interi\u00e9ri, mal\u00e1 spotreba energie, r\u00fdchla dostupnos\u0165 a po\u017eadovan\u00e1 presnos\u0165. To s\u00fa po\u017eiadavky, ktor\u00e9 s\u00fa kladen\u00e9 na lokaliza\u010dn\u00e9 slu\u017eby. Android OS m\u00e1 dva mo\u017en\u00e9 pr\u00edstupy k tak\u00fdmto lokaliza\u010dn\u00fdm slu\u017eb\u00e1m. android.location je API, ktor\u00e9 poskytuje priamy pr\u00edstup k lokaliza\u010dn\u00fdm slu\u017eb\u00e1m. Tento pr\u00edstup je n\u00edzko \u00farov\u0148ov\u00fd a aby bola aplik\u00e1cia optimalizovan\u00e1 je potrebn\u00e9, aby program\u00e1tor mal dobr\u00e9 znalosti tejto problematiky. S ka\u017edou novou verziou Android OS sa \u010diasto\u010dne menia podmienky, ak\u00fdm sp\u00f4sobom sa k lokaliza\u010dn\u00fdm slu\u017eb\u00e1m pristupuje a pri vyu\u017eit\u00ed tohoto API je \"na pleciach program\u00e1tora\" prisp\u00f4sobi\u0165 aplik\u00e1ciu aby fungovala aj na nov\u0161ej verzii Andorid-u. Pre v\u0161etky tieto nev\u00fdhody nie je odpor\u00fa\u010dan\u00e9 pou\u017e\u00edva\u0165 tento n\u00edzko \u00farov\u0148ov\u00fd pr\u00edstup . Odpor\u00fa\u010dan\u00e9 je vyu\u017e\u00edva\u0165 pr\u00edstup vy\u0161\u0161ej \u00farovne, ktor\u00fd je pop\u00edsan\u00fd v nasleduj\u00facej \u010dasti. Rozhranie Google Location Services API , ktor\u00e9 je s\u00fa\u010das\u0165ou slu\u017eieb Google Play, je preferovan\u00fdm sp\u00f4sobom, ako do aplik\u00e1cie prida\u0165 lokaliza\u010dn\u00e9 slu\u017eby. Pon\u00faka jednoduch\u0161ie API, vy\u0161\u0161iu presnos\u0165, 'geofencing' s n\u00edzkou spotrebou a \u010fal\u0161ie. Slu\u017eba Google Location API \u00b6 T\u00e1to slu\u017eba je s\u00fa\u010das\u0165ou rozsiahleho bal\u00edka Google play services [ Location and Context APIs ]. Tento bal\u00edk obsahuje nasleduj\u00face doplnkov\u00e9 slu\u017eby: Poloha: Places API - Poskytuje pou\u017e\u00edvate\u013eom kontextov\u00e9 inform\u00e1cie o tom, kde sa nach\u00e1dzaj\u00fa a \u010do sa nach\u00e1dza v ich okol\u00ed. Z\u00edskate pr\u00edstup k podrobn\u00fdm inform\u00e1ci\u00e1m o 100 mili\u00f3noch miest v r\u00f4znych kateg\u00f3ri\u00e1ch. Geofencing - Geofencing kombinuje znalos\u0165 aktu\u00e1lnej polohy pou\u017e\u00edvate\u013ea a vedomosti o vzdialenosti pou\u017e\u00edvate\u013ea k miestam, ktor\u00e9 m\u00f4\u017eu by\u0165 zauj\u00edmav\u00e9. Umo\u017e\u0148uje nastavi\u0165 zemepisn\u00e9 hranice okolo konkr\u00e9tnych miest a n\u00e1sledne prij\u00edma\u0165 ozn\u00e1menia, ke\u010f u\u017e\u00edvate\u013e vst\u00fapi alebo opust\u00ed tieto oblasti. Mo\u017enos\u0165 nastavi\u0165 viacero sledovan\u00fdch oblast\u00ed. Mo\u017enos\u0165 vytvorenia filtrov. Optimalizovanie pre v\u00fddr\u017e baterie: prisp\u00f4sobenie frekvencie aktualiz\u00e1ci\u00ed na z\u00e1klade polohy u\u017e\u00edvate\u013ea a charakteru pohybu u\u017e\u00edvate\u013ea (bez pohybu, ch\u00f4dza, jazda autom, at\u010f). Location API - Z\u00edskajte \u00fadaje o polohe pre svoju aplik\u00e1ciu na z\u00e1klade kombinovan\u00fdch sign\u00e1lov zo senzorov zariadenia pomocou rozhrania API \u00fa\u010dinn\u00e9ho na bat\u00e9rie. \u010cinnos\u0165 Platforma Google Fit - z\u00e1znam, spravovanie, vizualiz\u00e1cia fitness aktiv\u00edt API rozhranie na rozpozn\u00e1vanie aktivity - toto rozhranie spracov\u00e1va sign\u00e1ly z viacer\u00fdch senzorov pri\u010dom db\u00e1 na n\u00edzku spotrebu zariadenia, aby presne detegovalo aktu\u00e1lnu aktivitu pou\u017e\u00edvate\u013ea. Senzor API - pr\u00edstup k d\u00e1tam zo senzorov \u010co je v okol\u00ed: Spr\u00e1vy z okolia Mo\u017enos\u0165 pripoji\u0165 sa na zariadenia v okol\u00ed Upozornenia z okolia - slu\u017eba zanikla v roku 2018 Pou\u017eitie Location API vy\u017eaduje Google Play services ! Z\u00e1kladn\u00e9 vlastnosti Location API: Poskytovate\u013e polohy inteligentne riadi n\u00edzko \u00farov\u0148ov\u00e9 technol\u00f3gie a na z\u00e1klade po\u017eiadaviek na presnos\u0165 vracia \u010do najlep\u0161ie \u00fadaje o polohe. Po\u017eiadavky na presnos\u0165 s\u00fa ur\u010den\u00e9 intervalom \"Vysok\u00e1 presnos\u0165\" a \"N\u00edzka spotreba\" Okam\u017eit\u00e1 dostupnos\u0165 aplik\u00e1cia m\u00e1 okam\u017eit\u00fd pr\u00edstup k najlep\u0161ej aktu\u00e1lnej polohe. Klasick\u00fd proces z\u00edskavania polohy m\u00f4\u017ee trva\u0165 aj nieko\u013eko desiatok sek\u00fand k\u00fdm sa z\u00edska poloha s GPS syst\u00e9mu. Okam\u017eit\u00e1 inform\u00e1cia o polohe je \u010dastokr\u00e1t z\u00edskan\u00e1 z hist\u00f3rie polohy, ktor\u00fa si vy\u017eiadala in\u00e1 aplik\u00e1cia. Z toho vypl\u00fdva, \u017ee presnos\u0165 tejto polohy nemus\u00ed by\u0165 dobr\u00e1, ale d\u00e1 sa vyu\u017ei\u0165 na prvotn\u00e9 prisp\u00f4sobenie kontextu aplik\u00e1cie, ktor\u00fd sa po z\u00edskan\u00ed presnej\u0161ej polohy znova uprav\u00ed. Energetick\u00e1 efekt\u00edvnos\u0165 minimalizovanie spotreby, na z\u00e1klade po\u017eiadaviek. Location API rob\u00ed automatick\u00fd v\u00fdber najvhodnej\u0161\u00edch nastaven\u00ed, pre dan\u00e9 po\u017eiadavky na presnos\u0165. napr. aplik\u00e1cia na popred\u00ed dost\u00e1va d\u00e1ta z vysokou presnos\u0165ou, pri prechode aplik\u00e1cie do pozadia sa presnos\u0165 obmedz\u00ed na periodick\u00e9 upozornenie na zmenu polohy. U\u017eito\u010dn\u00e9 odkazy \u00b6 Nastavenie Google Play services Kontrola povolenia a z\u00edskanie povolenia (permissions) Warning Pri pr\u00e1ci s mnoh\u00fdmi API treba zisti\u0165 ak\u00e9 povolenia dan\u00e9 API vy\u017eaduje. V star\u0161\u00edch verzi\u00e1ch Android bolo posta\u010duj\u00face prida\u0165 dan\u00e9 povolenie do AndroidManifest.xml a u\u017e\u00edvate\u013e pri in\u0161tal\u00e1ci\u00ed potvrdil/zamietol pridelenie dan\u00e9ho povolenia. Toto u\u017e, ale nie je posta\u010duj\u00face pri nov\u0161\u00edch verzi\u00e1ch Android OS, kde je u\u017e povinnos\u0165 si vy\u017eiada\u0165 dan\u00e9 povolenie aj pri samotnom behu aplik\u00e1cie, vi\u010f odkaz vy\u0161\u0161ie. Pr\u00edklady na pr\u00e1cu s Location API: Z\u00edskanie poslednej zn\u00e1mej poz\u00edcie Pravideln\u00e1 aktualiz\u00e1cia polohy","title":"Senzory"},{"location":"senzory/#senzory","text":"T\u00e1to predn\u00e1\u0161ka sa zaober\u00e1 t\u00e9mou vstavan\u00fdch senzorov v syst\u00e9me Android ale aj lokaliza\u010dn\u00fdm podsyst\u00e9mom Location API.","title":"Senzory"},{"location":"senzory/#uvod-do-senzorov","text":"V\u00e4\u010d\u0161ina dne\u0161n\u00fdch Android zariaden\u00ed obsahuje vstavan\u00e9 senzory, ktor\u00e9 umo\u017e\u0148uj\u00fa mera\u0165 zr\u00fdchlenie, nato\u010denie zariadenia a mnoho \u010fal\u0161\u00edch fyzik\u00e1lnych veli\u010d\u00edn. Tieto senzory s\u00fa schopn\u00e9 poskytn\u00fa\u0165 surov\u00e9 d\u00e1ta s ve\u013ekou presnos\u0165ou a vo ve\u013ekom rozsahu a s\u00fa u\u017eito\u010dn\u00e9, ak chceme monitorova\u0165 pohyb alebo polohu zariadenia v trojrozmernom priestore alebo ak chceme monitorova\u0165 zmeny okolit\u00e9ho prostredia v bl\u00edzkosti zariadenia. Napr\u00edklad hra m\u00f4\u017ee sledova\u0165 \u00fadaje z akcelerometra a identifikova\u0165 zlo\u017eit\u00e9 gest\u00e1 a pohyby pou\u017e\u00edvate\u013ea, ako napr\u00edklad naklonenie, chvenie, rot\u00e1cia a pod. Podobne aj aplik\u00e1cia na po\u010dasie m\u00f4\u017ee na v\u00fdpo\u010det a ur\u010denie rosn\u00e9ho bodu pou\u017ei\u0165 sn\u00edma\u010d teploty a vlhkosti alebo navig\u00e1cia m\u00f4\u017ee vyu\u017ei\u0165 d\u00e1ta z trojosov\u00e9ho magnetometra, ktor\u00fd sn\u00edma geomagnetick\u00e9 pole Zeme a d\u00e1ta z akcelerometra na spresnenie navig\u00e1cie. Platforma Android podporuje tri kateg\u00f3rie senzorov: Pohybov\u00e9 senzory Tieto senzory meraj\u00fa fyzik\u00e1lne veli\u010diny ako: zr\u00fdchlenie a rota\u010dn\u00e9 sily pozd\u013a\u017e troch os\u00ed. Do tejto kateg\u00f3rie patria akcelerometre, gravita\u010dn\u00e9 senzory, gyroskopy a senzory nato\u010denia. Senzory prostredia Tieto senzory meraj\u00fa r\u00f4zne parametre prostredia, ako je teplota a tlak okolit\u00e9ho vzduchu, osvetlenie a vlhkos\u0165. T\u00e1to kateg\u00f3ria zah\u0155\u0148a barometre, fotometre (meranie intenzity svetla) a teplomery. Polohov\u00e9 senzory Tieto senzory meraj\u00fa fyzick\u00fa polohu zariadenia. T\u00e1to kateg\u00f3ria zah\u0155\u0148a senzory orient\u00e1cie a magnetometre. V syst\u00e9me Android m\u00f4\u017eeme senzory e\u0161te rozdeli\u0165 pod\u013ea toho, \u010di \u00fadaje poch\u00e1dzaj\u00fa priamo z fyzick\u00e9ho senzora alebo ide o softv\u00e9rov\u00fd senzor, ktor\u00fd poskytuje u\u017e predspracovan\u00e9 d\u00e1ta. Predspracovanie d\u00e1t m\u00f4\u017ee zah\u0155\u0148a\u0165 napr\u00edklad: filtrovanie d\u00e1t, f\u00faziu d\u00e1t z r\u00f4znych senzorov alebo transformovanie d\u00e1t do inej formy. Hardv\u00e9rov\u00e9 senzory odvodzuj\u00fa \u00fadaje priamym meran\u00edm \u0161pecifick\u00fdch vlastnost\u00ed prostredia. Medzi hardv\u00e9rov\u00e9 senzory rad\u00edme: Mikrof\u00f3n Kamera Teplota Poloha (GPS) Accelerometer Proximity Tlak Svetelnos\u0165 Medzi softv\u00e9rov\u00e9 rad\u00edme: Gravit\u00e1cia Line\u00e1rna akceler\u00e1cia Orient\u00e1cia Android poskytuje rozsiahly framework na pr\u00edstup k senzorom. Tento framework poskytuje nieko\u013eko tried a rozhran\u00ed, ktor\u00e9 m\u00f4\u017eeme vyu\u017ei\u0165 napr\u00edklad na: Ur\u010di\u0165 ak\u00e9 senzory s\u00fa k dispoz\u00edcii na danom zariaden\u00ed. Ka\u017ed\u00fd v\u00fdrobca zariaden\u00ed si s\u00e1m ur\u010duje ak\u00fdm senzormi osad\u00ed svoje zariadenia. Nie je to \u0161tandardizovan\u00e9. Ur\u010di\u0165 vlastnosti jednotliv\u00fdch sn\u00edma\u010dov, napr\u00edklad maxim\u00e1lny dosah, v\u00fdrobca, po\u017eiadavky na nap\u00e1janie a rozl\u00ed\u0161enie. Z\u00edska\u0165 surov\u00e9 \u00fadaje zo sn\u00edma\u010da a definujte minim\u00e1lnu vzorkovaciu frekvenciu (ako \u010dasto dost\u00e1vame d\u00e1ta ). Slov\u00ed\u010dko minim\u00e1lne je pou\u017eit\u00e9 z toho d\u00f4vodu, \u017ee senzory s\u00fa zdielan\u00e9 medzi v\u0161etk\u00fdmi aplik\u00e1ciami zariadenia. V pr\u00edpade ak niektor\u00e1 aplik\u00e1cia po\u017eaduje vy\u0161\u0161iu vzorkovaciu frekvenciu ako posta\u010dovala pre na\u0161u aplik\u00e1ciu, tak vzorkovacia frekvencia sa zv\u00fd\u0161i, \u010do ovplyvni aj vzorkovanie pre na\u0161u aplik\u00e1ciu. Hodnota vzorkovacej frekvencie ale nem\u00f4\u017ee klesn\u00fa\u0165 pod nami nastaven\u00e9 minimum. Zaregistrovanie a zru\u0161enie registr\u00e1cie na odoberanie udalost\u00ed od senzora. Pr\u00edklady udalost\u00ed, na ktor\u00e9 sa m\u00f4\u017eeme registrova\u0165 s\u00fa: nov\u00e1 hodnota, zmena presnosti, zmena citlivosti a pod. M\u00e1lo zariaden\u00ed so syst\u00e9mom Android m\u00e1 ka\u017ed\u00fd typ senzora. Napr\u00edklad v\u00e4\u010d\u0161ina mobiln\u00fdch telef\u00f3nov a tabletov m\u00e1 akcelerometer a magnetometer, ale menej pr\u00edstrojov m\u00e1 barometre alebo teplomery. Zariadenie m\u00f4\u017ee ma\u0165 tie\u017e viac ako jeden senzor dan\u00e9ho typu. Napr\u00edklad zariadenie m\u00f4\u017ee ma\u0165 dva sn\u00edma\u010de gravit\u00e1cie, z ktor\u00fdch ka\u017ed\u00fd m\u00e1 in\u00fd rozsah. senzor typ popis Be\u017en\u00e9 pou\u017eitia TYPE_ACCELEROMETER hardv\u00e9r Zmeria silu zr\u00fdchlenia v m/s^2 m/s^2 , ktor\u00e1 p\u00f4sob\u00ed na zariadenie vo v\u0161etk\u00fdch troch os\u00e1ch (x, y a z), vr\u00e1tane gravita\u010dnej sily. Detekcia pohybu (chvenie, n\u00e1klon at\u010f.). TYPE_AMBIENT_TEMPERATURE hardv\u00e9r Zmeria teplotu okolia v stup\u0148och Celzia (\u00b0C). Pozri pozn\u00e1mku ni\u017e\u0161ie. Monitorovanie teploty vzduchu. TYPE_GRAVITY Softv\u00e9r alebo hardv\u00e9r Zmeria gravita\u010dn\u00fa silu v m/s^2 m/s^2 , ktor\u00e1 p\u00f4sob\u00ed na zariadenie na v\u0161etk\u00fdch troch fyzick\u00fdch os\u00e1ch (x, y, z). Detekcia pohybu (chvenie, n\u00e1klon at\u010f.). TYPE_GYROSCOPE hardv\u00e9r Zmeria r\u00fdchlos\u0165 rot\u00e1cie zariadenia v rad / s okolo ka\u017edej z troch fyzick\u00fdch os\u00ed (x, y a z). Detekcia rot\u00e1cie (rot\u00e1cia, oto\u010denie at\u010f.). TYPE_LIGHT hardv\u00e9r Meria \u00farove\u0148 okolit\u00e9ho svetla (osvetlenie) v lx . Ovl\u00e1danie jasu obrazovky. TYPE_LINEAR_ACCELERATION Softv\u00e9r alebo hardv\u00e9r Zmeria silu zr\u00fdchlenia v m/s^2 m/s^2 , ktor\u00e1 p\u00f4sob\u00ed na zariadenie vo v\u0161etk\u00fdch troch os\u00e1ch (x, y a z), s v\u00fdnimkou gravita\u010dnej sily. Monitorovanie zr\u00fdchlenia pozd\u013a\u017e jednej osi. TYPE_MAGNETIC_FIELD hardv\u00e9r Zmeria sa okolit\u00e9 geomagnetick\u00e9 pole pre v\u0161etky tri fyzik\u00e1lne osi (x, y, z) v \u03bcT. Vytvorenie kompasu. TYPE_ORIENTATION softv\u00e9r Zmeria stupne nato\u010denia, ktor\u00e9 zariadenie vykon\u00e1 okolo v\u0161etk\u00fdch troch fyzick\u00fdch os\u00ed (x, y, z). Od API \u00farovne 3 m\u00f4\u017eete z\u00edska\u0165 maticu n\u00e1klonu a rota\u010dn\u00fa maticu pre zariadenie pomocou gravita\u010dn\u00e9ho senzora a senzora geomagnetick\u00e9ho po\u013ea v spojen\u00ed s touto met\u00f3dou getRotationMatrix() . Ur\u010denie polohy zariadenia. TYPE_PRESSURE hardv\u00e9r Zmeria tlak okolit\u00e9ho vzduchu v hPa alebo mbar. Monitorovanie zmien tlaku vzduchu. TYPE_PROXIMITY hardv\u00e9r Zmeria bl\u00edzkos\u0165 objektu v cm vzh\u013eadom na obrazovku zariadenia. Tento senzor sa zvy\u010dajne pou\u017e\u00edva na ur\u010denie, \u010di je sl\u00fachadlo dr\u017ean\u00e9 pri uchu osoby. Poloha telef\u00f3nu po\u010das hovoru. TYPE_RELATIVE_HUMIDITY hardv\u00e9r Zmeria relat\u00edvnu vlhkos\u0165 okolia v percent\u00e1ch (%). Monitorovanie rosn\u00e9ho bodu, absol\u00fatnej a relat\u00edvnej vlhkosti. TYPE_ROTATION_VECTOR Softv\u00e9r alebo hardv\u00e9r Zmeria orient\u00e1ciu zariadenia poskytnut\u00edm troch prvkov rota\u010dn\u00e9ho vektora zariadenia. Detekcia pohybu a detekcia rot\u00e1cie. TYPE_TEMPERATURE hardv\u00e9r Zmeria teplotu zariadenia v stup\u0148och Celzia (\u00b0C). T\u00e1to implement\u00e1cia senzora sa medzi zariadeniami l\u00ed\u0161i a tento senzor bol nahraden\u00fd TYPE_AMBIENT_TEMPERATURE senzorom v API Level 14 Monitorovanie teploty.","title":"\u00davod do senzorov"},{"location":"senzory/#framework","text":"K senzorom m\u00f4\u017eete pristupova\u0165 a z\u00edskava\u0165 nespracovan\u00e9 t.j. surov\u00e9 d\u00e1ta pomocou frameworku ktor\u00fd je s\u00fa\u010das\u0165ou android.hardware bal\u00edka a obsahuje nasleduj\u00face triedy a rozhrania: SensorManager T\u00fato triedu m\u00f4\u017eete pou\u017ei\u0165 na vytvorenie in\u0161tancie slu\u017eby sp\u00e4tej so senzormi. T\u00e1to trieda poskytuje r\u00f4zne met\u00f3dy pre pr\u00edstup a zoznam senzorov, registr\u00e1ciu a zru\u0161enie registr\u00e1cie prij\u00edmania udalost\u00ed senzorov. T\u00e1to trieda tie\u017e poskytuje nieko\u013eko kon\u0161t\u00e1nt, ktor\u00e9 sa pou\u017e\u00edvaj\u00fa na definovanie presnosti senzora, nastavenie r\u00fdchlosti z\u00edskavania \u00fadajov (vzorkovacia frekvencia) a kalibr\u00e1ciu senzorov. Sensor T\u00fato triedu m\u00f4\u017eete pou\u017ei\u0165 na vytvorenie in\u0161tancie konkr\u00e9tneho senzora. T\u00e1to trieda poskytuje r\u00f4zne met\u00f3dy, ktor\u00e9 v\u00e1m umo\u017e\u0148uj\u00fa ur\u010di\u0165 schopnosti senzora. SensorEvent Syst\u00e9m pou\u017e\u00edva t\u00fato triedu na vytvorenie objektu udalosti senzora, ktor\u00fd poskytuje inform\u00e1cie o udalosti ktor\u00fa emitoval senzor. Objekt SenzorEvent obsahuje nasleduj\u00face inform\u00e1cie: prvotn\u00e9 \u00fadaje senzora, typ senzora, ktor\u00fd generoval udalos\u0165, presnos\u0165 \u00fadajov a \u010dasov\u00e9 raz\u00edtko udalosti. SensorEventListener Toto rozhranie m\u00f4\u017eete pou\u017ei\u0165 na vytvorenie dvoch met\u00f3d sp\u00e4tn\u00e9ho volania, ktor\u00e9 prij\u00edmaj\u00fa ozn\u00e1menia (udalosti senzora) pri zmene hodn\u00f4t senzora alebo pri zmene presnosti senzora.","title":"Framework"},{"location":"senzory/#identifikovanie-senzorov-a-ich-vlastnosti","text":"Z\u00edskanie in\u0161tancie triedy SensorManager Tento krok predstavuje vstupn\u00fd bod, ktor\u00fd je nutn\u00e9 spravi\u0165, aby sme vedeli pristupova\u0165 k senzor framework-u. private SensorManager mSensorManager ; ... mSensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); Pomocou in\u0161tancie triedy SensorManager si vieme vy\u017eiada\u0165 zoznam dostupn\u00fdch senzorov. Vy\u017eiadame si bu\u010f cel\u00fd zoznam alebo iba ur\u010dit\u00fa kateg\u00f3riu: TYPE_ALL - v\u0161etky dostupn\u00e9 senzory TYPE_GYROSCOPE , TYPE_LINEAR_ACCELERATION , TYPE_GRAVITY` List < Sensor > deviceSensors = mSensorManager . getSensorList ( Sensor . TYPE_ALL ); Overenie \u010di dan\u00fd senzor existuje na zariaden\u00ed pomocou getDefaultSensor() . Ak dan\u00fd senzor v zariaden\u00ed existuje, tak vr\u00e1ti in\u0161tanciu objektu Senzor . Ak zariadenie obsahuje viac ako jeden senzor dan\u00e9ho typu, jeden zo senzorov mus\u00ed by\u0165 ozna\u010den\u00fd ako predvolen\u00fd senzor. Ak pre dan\u00fd typ senzora neexistuje predvolen\u00fd senzor, volanie met\u00f3dy vr\u00e1ti hodnotu null , \u010do znamen\u00e1, \u017ee tak\u00fdto typ senzora nie je v zariaden\u00ed osaden\u00fd. private SensorManager mSensorManager ; ... mSensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); if ( mSensorManager . getDefaultSensor ( Sensor . TYPE_MAGNETIC_FIELD ) != null ){ // Success! There's a magnetometer. } else { // Failure! No magnetometer. } Pomocou z\u00edskan\u00e9ho objektu Senzor vieme ur\u010dit aj \u010fal\u0161ie vlastnosti konkr\u00e9tneho senzora tak, \u017ee zavol\u00e1me pr\u00edslu\u0161n\u00e9 met\u00f3dy napr: Verejn\u00e9 met\u00f3dy int getMaxDelay() float getMaximumRange() int getMinDelay() String getName() float getPower() int getReportingMode() float getResolution() String getStringType() int getType() String getVendor() int getVersion() Vzorkovacia frekvencia Met\u00f3da getMinDelay() je u\u017eito\u010dn\u00e1 ak chceme z\u00edska\u0165 inform\u00e1ciu ak\u00e1 je maxim\u00e1lna vzorkovacia frekvencia. T\u00e1to premenn\u00e1 vracia minim\u00e1lnu peri\u00f3du vzorkovania v mikrosekund\u00e1ch na v\u00fdpo\u010det vzorkovacej frekvencie pou\u017eije zn\u00e1my vzorec: $$ f_{vzorkovacia} = \\frac{1}{getMinDelay()\\times10^6}[Hz] $$ Ak met\u00f3da getMinDelay() vr\u00e1ti 0 tak v tomto pr\u00edpade senzor vyvol\u00e1 udalos\u0165 iba pri zmene meranej veli\u010diny","title":"Identifikovanie senzorov a ich vlastnosti"},{"location":"senzory/#komunikacia-so-senzormi","text":"Komunik\u00e1cia so senzorom prebieha asynchr\u00f3nnym sp\u00f4sobom. Senzory Androidu s\u00fa riaden\u00e9 extern\u00fdmi slu\u017ebami a komunikuj\u00fa na z\u00e1klade odosielania udalosti. Aplik\u00e1cia sa mus\u00ed zaregistrova\u0165 na pr\u00edjem t\u00fdchto udalost\u00ed implementovan\u00edm rozhrania SensorEventListener . V rozhran\u00ed SensorEventListener existuj\u00fa dve met\u00f3dy sp\u00e4tn\u00e9ho volania tzv callback met\u00f3dy onAccuracyChanged() a onSensorChanged() . Android vol\u00e1 tieto met\u00f3dy v\u017edy, ke\u010f nastane t\u00e1to situ\u00e1cia: Ak sa zmen\u00ed presnos\u0165 senzora syst\u00e9m vol\u00e1 met\u00f3du onAccuracyChanged() a poskytne referenciu na Sensor objekt, ktor\u00e9ho sa dan\u00e1 situ\u00e1cia t\u00fdka. Ak senzor na\u010d\u00edta nov\u00fa hodnotu syst\u00e9m vol\u00e1 met\u00f3du onSensorChanged() a poskytne referenciu na SensorEvent . Tento objekt obsahuje nasleduj\u00face atrib\u00faty: Atrib\u00faty public int accuracy Presnos\u0165 tejto udalosti. public Sensor sensor Senzor, ktor\u00fd generoval t\u00fato udalos\u0165. public long timestamp \u010cas v nanosekund\u00e1ch, v ktorom sa udalos\u0165 stala public final float[] values D\u013a\u017eka a obsah po\u013ea values z\u00e1vis\u00ed od toho, pre ktor\u00fd typ senzoru bol dan\u00fd objekt vytvoren\u00fd. Atrib\u00fat SensorEvent.values D\u00f4le\u017eit\u00e9 je si uvedomi\u0165, \u017ee objekt SensorEvent sa pou\u017e\u00edva pre v\u0161etky typy senzorov, ktor\u00e9 poskytuj\u00fa r\u00f4zne d\u00e1ta a preto na pole hodn\u00f4t values sa treba pozrie\u0165 v\u017edy v kontexte konkr\u00e9tneho senzora, ktor\u00fd ur\u010duje \u010do ulo\u017e\u00ed do dan\u00e9ho po\u013ea. Zaregistrovania odberu udalost\u00ed od senzora @Override protected void onResume () { super . onResume (); mSensorManager . registerListener ( this , mLight , SensorManager . SENSOR_DELAY_NORMAL ); } Pri registr\u00e1cii sme definovali pomocou kon\u0161tanty SENSOR_DELAY_NORMAL , minim\u00e1lnu vzorkovaciu frekvenciu alebo inak povedan\u00e9 maxim\u00e1lny \u010das medzi vzorkami. Pre ka\u017ed\u00fd typ aplik\u00e1cie je vhodne vybra\u0165 t\u00fato hodnota tak, aby zodpovedala po\u017eiadavk\u00e1m, ktor\u00e9 s\u00fa kladen\u00e9 na aplik\u00e1ciu. Z\u00e1rove\u0148 v\u0161ak treba bra\u0165 do \u00favahy v\u00fdpo\u010dtov\u00e9 a s t\u00fdm sp\u00e4t\u00e9 aj energetick\u00e9 n\u00e1roky, ktor\u00e9 vypl\u00fdvaj\u00fa z pou\u017eitia senzora a nastavenia ve\u013emi vysokej vzorkovacej frekvencie. Exituj\u00fa tieto kon\u0161tanty, ktor\u00e9 maj\u00fa napom\u00f4c\u0165 vybra\u0165 vhodn\u00fa vzorkovaciu frekvenciu: u\u017e spomenut\u00e1 SENSOR_DELAY_NORMAL a potom SENSOR_DELAY_GAME , SENSOR_DELAY_UI , alebo \u0161pecifick\u00e1 hodnota zadan\u00e1 v mikrosekund\u00e1ch. Ako u\u017e bolo spomenut\u00e9 v predch\u00e1dzaj\u00facich \u010dastiach, vzorkovacia frekvencia sa m\u00f4\u017ee meni\u0165 vzh\u013eadom na to, \u017ee senzory s\u00fa zdielan\u00e9 medzi v\u0161etk\u00fdmi aplik\u00e1ciami. Ak in\u00e1 aplik\u00e1cia potrebuje vy\u0161\u0161iu vzorkovaciu frekvenciu, tak aj na\u0161a aplik\u00e1cia bude dost\u00e1va\u0165 \u00fadaju \u010dastej\u0161ie. Neexistuje met\u00f3da pomocou ktorej by sa dala ur\u010di\u0165 aktu\u00e1lna vzorkovacia frekvencia, jedin\u00e1 mo\u017enos\u0165 je ur\u010di\u0165 ju nepriamo pomocou \u010dasovej zn\u00e1mky, ktor\u00e1 je obsiahnut\u00e1 v objekte SensorEvent . Zru\u0161enie registr\u00e1cie odberu udalost\u00ed od senzora @Override protected void onPause () { super . onPause (); mSensorManager . unregisterListener ( this ); } \u017divotn\u00fd cyklus Pri pr\u00e1ci so senzormi nesmieme zabudn\u00fa\u0165 na \u017eivotn\u00fd cyklus aplik\u00e1cie a preto registrovanie a odregistrovanie vykon\u00e1vame v met\u00f3dach \u017eivotn\u00e9ho cyklu onResume , onPause tak aby sme zbyto\u010dne nepou\u017e\u00edvali senzory, ktor\u00e9 u\u017e nepotrebujeme (zni\u017eovanie spotreby). Syst\u00e9m senzory nevyp\u00edna automaticky! Komplexn\u00fd pr\u00edklad pou\u017eitia Frameworku na pr\u00e1cu so senzormi public class SensorActivity extends Activity implements SensorEventListener { private SensorManager sensorManager ; private Sensor mLight ; @Override public final void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . main ); sensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); mLight = sensorManager . getDefaultSensor ( Sensor . TYPE_LIGHT ); } @Override public final void onAccuracyChanged ( Sensor sensor , int accuracy ) { // Do something here if sensor accuracy changes. } @Override public final void onSensorChanged ( SensorEvent event ) { // The light sensor returns a single value. // Many sensors return 3 values, one for each axis. float lux = event . values [ 0 ] ; // Do something with this sensor value. } @Override protected void onResume () { super . onResume (); sensorManager . registerListener ( this , mLight , SensorManager . SENSOR_DELAY_NORMAL ); } @Override protected void onPause () { super . onPause (); sensorManager . unregisterListener ( this ); } }","title":"Komunik\u00e1cia so senzormi"},{"location":"senzory/#vysporiadanie-sa-s-roznorodostou-android-zariadeni","text":"Na zistenie pr\u00edtomnosti dan\u00e9ho senzora v zariaden\u00ed m\u00e1me dve komplement\u00e1rne mo\u017enosti: Detegova\u0165 senzory za behu a pod\u013ea potreby zapn\u00fa\u0165 alebo vypn\u00fa\u0165 funkcie aplik\u00e1cie. private SensorManager sensorManager ; ... sensorManager = ( SensorManager ) getSystemService ( Context . SENSOR_SERVICE ); if ( sensorManager . getDefaultSensor ( Sensor . TYPE_PRESSURE ) != null ){ // Success! There's a pressure sensor. } else { // Failure! No pressure sensor. } Pou\u017eitie filtrov v slu\u017ebe Google Play - zak\u00e1zanie in\u0161tal\u00e1cie aplik\u00e1cie u\u017e priamo v obchode Google Play. Tento filter sa nastavuje v AndroidManifest.xml s\u00fabore pomocou xml elementu <user-feature> <uses-feature android:name= \"android.hardware.sensor.accelerometer\" android:required= \"true\" /> android:required= ur\u010duje, \u010di dan\u00fd senzor je nevyhnutn\u00fd pre fungovanie aplik\u00e1cie. Hodnota false , dovol\u00ed aplik\u00e1ciu nain\u0161talova\u0165 aj ke\u010f dan\u00fd senzor nie je v zariaden\u00ed pr\u00edtomn\u00fd, aplik\u00e1cia sa mus\u00ed tomu prisp\u00f4sobi\u0165. Note Pre prehladnos\u0165 sa odpor\u00fa\u010da v\u0161etky pou\u017e\u00edvan\u00e9 senzory aj tie nie kritick\u00e9 pre chod aplik\u00e1cie, zap\u00edsa\u0165 do AndroidManifest.xml s\u00faboru.","title":"Vysporiadanie sa s r\u00f4znorodos\u0165ou Android zariaden\u00ed"},{"location":"senzory/#suradnicovy-system-senzorov","text":"Pri pr\u00e1ci so senzormi, ktor\u00e9 z princ\u00edpu \u010dinnosti meraj\u00fa d\u00e1ta v osiach, Android vyu\u017e\u00edva \u0161tandardn\u00fd 3-osov\u00fd s\u00faradnicov\u00fd syst\u00e9m. Pre v\u00e4\u010d\u0161inu senzorov je s\u00faradnicov\u00fd syst\u00e9m definovan\u00fd vzh\u013eadom na obrazovku zariadenia, ke\u010f je zariadenie dr\u017ean\u00e9 v takzvanej nat\u00edvnej polohe (pozri obr\u00e1zok) . Ak je zariadenie dr\u017ean\u00e9 v tejto polohe os X je vodorovn\u00e1 a ukazuje doprava, os Y je zvisl\u00e1 a ukazuje nahor a os Z ukazuje smerom k vonkaj\u0161ej strane obrazovky. V tomto syst\u00e9me maj\u00fa s\u00faradnice za obrazovkou z\u00e1porn\u00e9 hodnoty Z. Tento s\u00faradnicov\u00fd syst\u00e9m pou\u017e\u00edvaj\u00fa nasleduj\u00face senzory: accelerometer, gravita\u010dn\u00fd senzor, gyroskop, line\u00e1rna akceler\u00e1cia, senzor geomagnetick\u00e9ho po\u013ea (kompas) S\u00faradnicov\u00fd syst\u00e9m pou\u017e\u00edvan\u00fd v Android OS D\u00f4le\u017eit\u00e9 vlastnosti: Je d\u00f4le\u017eit\u00e9 si pam\u00e4ta\u0165, \u017ee osy pri zmene orient\u00e1cie obrazovky sa nemenia/nevymie\u0148aj\u00fa- s\u00faradnicov\u00fd syst\u00e9m sa nikdy nemen\u00ed. Nat\u00edvna poloha nemus\u00ed by\u0165 v\u017edy tak\u00e1, \u017ee zariadenie je orientovan\u00e9 na v\u00fd\u0161ku. Pri mnoh\u00fdch tabletov\u00fdch zariadeniach je prirodzen\u00e1 orient\u00e1cia na \u0161\u00edrku. S\u00faradnicov\u00fd syst\u00e9m senzorov je v\u017edy zalo\u017een\u00fd na nat\u00edvnej orient\u00e1cii zariadenia. Ak aplik\u00e1cia chce vyu\u017ei\u0165 \u00fadaje senzora a transformova\u0165 na s\u00faradnice displeja, mus\u00edme pou\u017ei\u0165 met\u00f3du getRotation() na ur\u010denie rot\u00e1cie obrazovky a n\u00e1sledne pou\u017ei\u0165 met\u00f3du remapCoordinateSystem() pomocou ktorej sa mapuj\u00fa s\u00faradnice senzora na s\u00faradnice obrazovky. Note Niektor\u00e9 senzory a met\u00f3dy pou\u017e\u00edvaj\u00fa s\u00faradnicov\u00fd syst\u00e9m, ktor\u00fd je relat\u00edvny k svetov\u00e9mu referen\u010dn\u00e9mu r\u00e1mcu (na rozdiel od referen\u010dn\u00e9ho r\u00e1mca zariadenia). Tieto senzory a met\u00f3dy vracaj\u00fa \u00fadaje, ktor\u00e9 predstavuj\u00fa pohyb zariadenia alebo polohu zariadenia vzh\u013eadom na Zem. Pre viac inform\u00e1ci\u00ed vi\u010f getOrientation() met\u00f3da, getRotationMatrix() met\u00f3da, senzor orient\u00e1cie a senzor rot\u00e1cie .","title":"S\u00faradnicov\u00fd syst\u00e9m senzorov"},{"location":"senzory/#osvedcene-postupy-pre-pristup-a-pouzivanie-senzorov","text":"Senzory pou\u017e\u00edvajte iba ke\u010f je aplik\u00e1cia v popred\u00ed od verzie Android 9 sa aplik\u00e1cie, ktor\u00e9 be\u017eia na pozad\u00ed musia prisp\u00f4sobi\u0165 nasleduj\u00facim obmedzeniam: V pr\u00edpade nepretr\u017eit\u00e9ho vzorkovania, napr. senzor akceleromer, gyroskop, aplik\u00e1cia nedost\u00e1va nov\u00e9 d\u00e1ta. V pr\u00edpade jednor\u00e1zov\u00e9ho merania alebo udalosti o zmene meranej hodnoty, aplik\u00e1cia taktie\u017e nedost\u00e1va nov\u00e9 d\u00e1ta. Vzh\u013eadom na tieto obmedzenia je nutn\u00e9 pou\u017e\u00edva\u0165 senzor iba ke\u010f je aplik\u00e1cia v popred\u00ed alebo vyu\u017ei\u0165 ForegroundService Dba\u0165 na dodr\u017eiavanie \u017eivotn\u00e9ho cyklu aplik\u00e1cie, t.j. onPause() odhl\u00e1si\u0165 pr\u00edjem, udalost\u00ed od senzora. Testovanie senzorov pomocou Android Emulatora Neblokova\u0165 met\u00f3du onSensorChanged() Nepou\u017e\u00edvajte met\u00f3dy alebo typy sn\u00edma\u010dov, ktor\u00e9 s\u00fa ozna\u010den\u00e9 ako deprecated t.j. zastaran\u00e9 Pred pou\u017eit\u00edm senzorov treba overi\u0165 \u010di je senzor naozaj pr\u00edtomn\u00fd v zariaden\u00ed Treba spr\u00e1vne zvoli\u0165 vzorkovaciu frekvenciu - treba zabr\u00e1ni\u0165 zbyto\u010dn\u00e9mu plytvaniu CPU a energiou","title":"Osved\u010den\u00e9 postupy pre pr\u00edstup a pou\u017e\u00edvanie senzorov"},{"location":"senzory/#urcenie-polohy-satelitna-navigacia","text":"Android poskytuje lokaliz\u00e1ciu na z\u00e1klade r\u00f4znych met\u00f3d: triangul\u00e1cia na z\u00e1klade BTS, WiFi pr\u00edstupov\u00e9 body a naj\u010dastej\u0161ie GPS. Cie\u013eom tohoto rie\u0161enia je docieli\u0165, \u010do najlep\u0161ie lokaliza\u010dn\u00e9 slu\u017eby v r\u00f4znych podmienkach a obmedzeniach. Lokaliz\u00e1cia v exteri\u00e9ry, v interi\u00e9ri, mal\u00e1 spotreba energie, r\u00fdchla dostupnos\u0165 a po\u017eadovan\u00e1 presnos\u0165. To s\u00fa po\u017eiadavky, ktor\u00e9 s\u00fa kladen\u00e9 na lokaliza\u010dn\u00e9 slu\u017eby. Android OS m\u00e1 dva mo\u017en\u00e9 pr\u00edstupy k tak\u00fdmto lokaliza\u010dn\u00fdm slu\u017eb\u00e1m. android.location je API, ktor\u00e9 poskytuje priamy pr\u00edstup k lokaliza\u010dn\u00fdm slu\u017eb\u00e1m. Tento pr\u00edstup je n\u00edzko \u00farov\u0148ov\u00fd a aby bola aplik\u00e1cia optimalizovan\u00e1 je potrebn\u00e9, aby program\u00e1tor mal dobr\u00e9 znalosti tejto problematiky. S ka\u017edou novou verziou Android OS sa \u010diasto\u010dne menia podmienky, ak\u00fdm sp\u00f4sobom sa k lokaliza\u010dn\u00fdm slu\u017eb\u00e1m pristupuje a pri vyu\u017eit\u00ed tohoto API je \"na pleciach program\u00e1tora\" prisp\u00f4sobi\u0165 aplik\u00e1ciu aby fungovala aj na nov\u0161ej verzii Andorid-u. Pre v\u0161etky tieto nev\u00fdhody nie je odpor\u00fa\u010dan\u00e9 pou\u017e\u00edva\u0165 tento n\u00edzko \u00farov\u0148ov\u00fd pr\u00edstup . Odpor\u00fa\u010dan\u00e9 je vyu\u017e\u00edva\u0165 pr\u00edstup vy\u0161\u0161ej \u00farovne, ktor\u00fd je pop\u00edsan\u00fd v nasleduj\u00facej \u010dasti. Rozhranie Google Location Services API , ktor\u00e9 je s\u00fa\u010das\u0165ou slu\u017eieb Google Play, je preferovan\u00fdm sp\u00f4sobom, ako do aplik\u00e1cie prida\u0165 lokaliza\u010dn\u00e9 slu\u017eby. Pon\u00faka jednoduch\u0161ie API, vy\u0161\u0161iu presnos\u0165, 'geofencing' s n\u00edzkou spotrebou a \u010fal\u0161ie.","title":"Ur\u010denie polohy / Satelitn\u00e1 navig\u00e1cia"},{"location":"senzory/#sluzba-google-location-api","text":"T\u00e1to slu\u017eba je s\u00fa\u010das\u0165ou rozsiahleho bal\u00edka Google play services [ Location and Context APIs ]. Tento bal\u00edk obsahuje nasleduj\u00face doplnkov\u00e9 slu\u017eby: Poloha: Places API - Poskytuje pou\u017e\u00edvate\u013eom kontextov\u00e9 inform\u00e1cie o tom, kde sa nach\u00e1dzaj\u00fa a \u010do sa nach\u00e1dza v ich okol\u00ed. Z\u00edskate pr\u00edstup k podrobn\u00fdm inform\u00e1ci\u00e1m o 100 mili\u00f3noch miest v r\u00f4znych kateg\u00f3ri\u00e1ch. Geofencing - Geofencing kombinuje znalos\u0165 aktu\u00e1lnej polohy pou\u017e\u00edvate\u013ea a vedomosti o vzdialenosti pou\u017e\u00edvate\u013ea k miestam, ktor\u00e9 m\u00f4\u017eu by\u0165 zauj\u00edmav\u00e9. Umo\u017e\u0148uje nastavi\u0165 zemepisn\u00e9 hranice okolo konkr\u00e9tnych miest a n\u00e1sledne prij\u00edma\u0165 ozn\u00e1menia, ke\u010f u\u017e\u00edvate\u013e vst\u00fapi alebo opust\u00ed tieto oblasti. Mo\u017enos\u0165 nastavi\u0165 viacero sledovan\u00fdch oblast\u00ed. Mo\u017enos\u0165 vytvorenia filtrov. Optimalizovanie pre v\u00fddr\u017e baterie: prisp\u00f4sobenie frekvencie aktualiz\u00e1ci\u00ed na z\u00e1klade polohy u\u017e\u00edvate\u013ea a charakteru pohybu u\u017e\u00edvate\u013ea (bez pohybu, ch\u00f4dza, jazda autom, at\u010f). Location API - Z\u00edskajte \u00fadaje o polohe pre svoju aplik\u00e1ciu na z\u00e1klade kombinovan\u00fdch sign\u00e1lov zo senzorov zariadenia pomocou rozhrania API \u00fa\u010dinn\u00e9ho na bat\u00e9rie. \u010cinnos\u0165 Platforma Google Fit - z\u00e1znam, spravovanie, vizualiz\u00e1cia fitness aktiv\u00edt API rozhranie na rozpozn\u00e1vanie aktivity - toto rozhranie spracov\u00e1va sign\u00e1ly z viacer\u00fdch senzorov pri\u010dom db\u00e1 na n\u00edzku spotrebu zariadenia, aby presne detegovalo aktu\u00e1lnu aktivitu pou\u017e\u00edvate\u013ea. Senzor API - pr\u00edstup k d\u00e1tam zo senzorov \u010co je v okol\u00ed: Spr\u00e1vy z okolia Mo\u017enos\u0165 pripoji\u0165 sa na zariadenia v okol\u00ed Upozornenia z okolia - slu\u017eba zanikla v roku 2018 Pou\u017eitie Location API vy\u017eaduje Google Play services ! Z\u00e1kladn\u00e9 vlastnosti Location API: Poskytovate\u013e polohy inteligentne riadi n\u00edzko \u00farov\u0148ov\u00e9 technol\u00f3gie a na z\u00e1klade po\u017eiadaviek na presnos\u0165 vracia \u010do najlep\u0161ie \u00fadaje o polohe. Po\u017eiadavky na presnos\u0165 s\u00fa ur\u010den\u00e9 intervalom \"Vysok\u00e1 presnos\u0165\" a \"N\u00edzka spotreba\" Okam\u017eit\u00e1 dostupnos\u0165 aplik\u00e1cia m\u00e1 okam\u017eit\u00fd pr\u00edstup k najlep\u0161ej aktu\u00e1lnej polohe. Klasick\u00fd proces z\u00edskavania polohy m\u00f4\u017ee trva\u0165 aj nieko\u013eko desiatok sek\u00fand k\u00fdm sa z\u00edska poloha s GPS syst\u00e9mu. Okam\u017eit\u00e1 inform\u00e1cia o polohe je \u010dastokr\u00e1t z\u00edskan\u00e1 z hist\u00f3rie polohy, ktor\u00fa si vy\u017eiadala in\u00e1 aplik\u00e1cia. Z toho vypl\u00fdva, \u017ee presnos\u0165 tejto polohy nemus\u00ed by\u0165 dobr\u00e1, ale d\u00e1 sa vyu\u017ei\u0165 na prvotn\u00e9 prisp\u00f4sobenie kontextu aplik\u00e1cie, ktor\u00fd sa po z\u00edskan\u00ed presnej\u0161ej polohy znova uprav\u00ed. Energetick\u00e1 efekt\u00edvnos\u0165 minimalizovanie spotreby, na z\u00e1klade po\u017eiadaviek. Location API rob\u00ed automatick\u00fd v\u00fdber najvhodnej\u0161\u00edch nastaven\u00ed, pre dan\u00e9 po\u017eiadavky na presnos\u0165. napr. aplik\u00e1cia na popred\u00ed dost\u00e1va d\u00e1ta z vysokou presnos\u0165ou, pri prechode aplik\u00e1cie do pozadia sa presnos\u0165 obmedz\u00ed na periodick\u00e9 upozornenie na zmenu polohy.","title":"Slu\u017eba Google Location API"},{"location":"senzory/#uzitocne-odkazy","text":"Nastavenie Google Play services Kontrola povolenia a z\u00edskanie povolenia (permissions) Warning Pri pr\u00e1ci s mnoh\u00fdmi API treba zisti\u0165 ak\u00e9 povolenia dan\u00e9 API vy\u017eaduje. V star\u0161\u00edch verzi\u00e1ch Android bolo posta\u010duj\u00face prida\u0165 dan\u00e9 povolenie do AndroidManifest.xml a u\u017e\u00edvate\u013e pri in\u0161tal\u00e1ci\u00ed potvrdil/zamietol pridelenie dan\u00e9ho povolenia. Toto u\u017e, ale nie je posta\u010duj\u00face pri nov\u0161\u00edch verzi\u00e1ch Android OS, kde je u\u017e povinnos\u0165 si vy\u017eiada\u0165 dan\u00e9 povolenie aj pri samotnom behu aplik\u00e1cie, vi\u010f odkaz vy\u0161\u0161ie. Pr\u00edklady na pr\u00e1cu s Location API: Z\u00edskanie poslednej zn\u00e1mej poz\u00edcie Pravideln\u00e1 aktualiz\u00e1cia polohy","title":"U\u017eito\u010dn\u00e9 odkazy"}]}