<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=assets/images/favicon.png><meta name=generator content="mkdocs-1.1, mkdocs-material-5.0.2"><title>VAMZ</title><link rel=stylesheet href=assets/stylesheets/main.07c9fbf5.min.css><link rel=stylesheet href=assets/stylesheets/palette.ecd4686e.min.css><meta name=theme-color content=#3f51b5><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style><link rel=stylesheet href=stylesheets/extra.css></head> <body dir=ltr data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#procesy-a-vlakna-multithreding class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=. title=VAMZ class="md-header-nav__button md-logo" aria-label=VAMZ> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 89 89"> <path d=M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z /> <path d=M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z style="fill-opacity: 0.5"/> <path d=M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z /> <path d=M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z style="fill-opacity: 0.25"/> </svg> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d=M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z /></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <span class="md-header-nav__topic md-ellipsis"> VAMZ </span> <span class="md-header-nav__topic md-ellipsis"> Procesy a vlákna <small>(multithreding)</small> </span> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d=M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z /></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d=M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z /></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Type to start searching </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=. class="md-tabs__link md-tabs__link--active"> Procesy a vlákna <small>(multithreding)</small> </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=. title=VAMZ class="md-nav__button md-logo" aria-label=VAMZ> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 89 89"> <path d=M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z /> <path d=M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z style="fill-opacity: 0.5"/> <path d=M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z /> <path d=M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z style="fill-opacity: 0.25"/> </svg> </a> VAMZ </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Procesy a vlákna <small>(multithreding)</small> <span class="md-nav__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d=M3,9H17V7H3V9M3,13H17V11H3V13M3,17H17V15H3V17M19,17H21V15H19V17M19,7V9H21V7H19M19,13H21V11H19V13Z /></svg> </span> </label> <a href=. title="Procesy a vlákna (multithreding)" class="md-nav__link md-nav__link--active"> Procesy a vlákna <small>(multithreding)</small> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d=M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z /></svg> </span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#procesy class=md-nav__link> Procesy </a> </li> <li class=md-nav__item> <a href=#vlakna class=md-nav__link> Vlákna </a> <nav class=md-nav aria-label=Vlákna> <ul class=md-nav__list> <li class=md-nav__item> <a href=#hlavne-ui-vlakno class=md-nav__link> Hlavné "UI" vlákno </a> </li> <li class=md-nav__item> <a href=#nastavenie-priority class=md-nav__link> Nastavenie priority </a> </li> <li class=md-nav__item> <a href=#pomocne-triedy-pre-pracu-z-vlaknami class=md-nav__link> Pomocné triedy pre prácu z vláknami </a> <nav class=md-nav aria-label="Pomocné triedy pre prácu z vláknami"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#asynctask class=md-nav__link> AsyncTask </a> </li> <li class=md-nav__item> <a href=#handlerthread class=md-nav__link> HandlerThread </a> <nav class=md-nav aria-label=HandlerThread> <ul class=md-nav__list> <li class=md-nav__item> <a href=#praca-s-handlerthread class=md-nav__link> Práca s HandlerThread </a> </li> <li class=md-nav__item> <a href=#zasobnik-sprav-handler class=md-nav__link> Zásobník správ - Handler </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#threadpool class=md-nav__link> ThreadPool </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#vlakna-a-zmeny-konfiguracierestart-aplikacie class=md-nav__link> Vlákna a zmeny konfigurácie(reštart aplikácie) </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#dlhotrvajuce-ulohy-na-pozadi class=md-nav__link> Dlhotrvajúce úlohy na pozadí </a> <nav class=md-nav aria-label="Dlhotrvajúce úlohy na pozadí "> <ul class=md-nav__list> <li class=md-nav__item> <a href=#obmedzenia-android-os-ktore-ovplyvnuju-vykonavanie-uloh-na-pozadi class=md-nav__link> Obmedzenia Android OS, ktoré ovplyvňujú vykonávanie úloh na pozadí </a> </li> <li class=md-nav__item> <a href=#workmanager class=md-nav__link> WorkManager </a> </li> <li class=md-nav__item> <a href=#foreground-services-sluzba-v-popredi class=md-nav__link> Foreground services / Služba v popredí </a> </li> <li class=md-nav__item> <a href=#alarmmanager class=md-nav__link> AlarmManager </a> </li> <li class=md-nav__item> <a href=#downloadmanager class=md-nav__link> DownloadManager </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=senzory/ title=Senzory class=md-nav__link> Senzory </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d=M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z /></svg> </span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#procesy class=md-nav__link> Procesy </a> </li> <li class=md-nav__item> <a href=#vlakna class=md-nav__link> Vlákna </a> <nav class=md-nav aria-label=Vlákna> <ul class=md-nav__list> <li class=md-nav__item> <a href=#hlavne-ui-vlakno class=md-nav__link> Hlavné "UI" vlákno </a> </li> <li class=md-nav__item> <a href=#nastavenie-priority class=md-nav__link> Nastavenie priority </a> </li> <li class=md-nav__item> <a href=#pomocne-triedy-pre-pracu-z-vlaknami class=md-nav__link> Pomocné triedy pre prácu z vláknami </a> <nav class=md-nav aria-label="Pomocné triedy pre prácu z vláknami"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#asynctask class=md-nav__link> AsyncTask </a> </li> <li class=md-nav__item> <a href=#handlerthread class=md-nav__link> HandlerThread </a> <nav class=md-nav aria-label=HandlerThread> <ul class=md-nav__list> <li class=md-nav__item> <a href=#praca-s-handlerthread class=md-nav__link> Práca s HandlerThread </a> </li> <li class=md-nav__item> <a href=#zasobnik-sprav-handler class=md-nav__link> Zásobník správ - Handler </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#threadpool class=md-nav__link> ThreadPool </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#vlakna-a-zmeny-konfiguracierestart-aplikacie class=md-nav__link> Vlákna a zmeny konfigurácie(reštart aplikácie) </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#dlhotrvajuce-ulohy-na-pozadi class=md-nav__link> Dlhotrvajúce úlohy na pozadí </a> <nav class=md-nav aria-label="Dlhotrvajúce úlohy na pozadí "> <ul class=md-nav__list> <li class=md-nav__item> <a href=#obmedzenia-android-os-ktore-ovplyvnuju-vykonavanie-uloh-na-pozadi class=md-nav__link> Obmedzenia Android OS, ktoré ovplyvňujú vykonávanie úloh na pozadí </a> </li> <li class=md-nav__item> <a href=#workmanager class=md-nav__link> WorkManager </a> </li> <li class=md-nav__item> <a href=#foreground-services-sluzba-v-popredi class=md-nav__link> Foreground services / Služba v popredí </a> </li> <li class=md-nav__item> <a href=#alarmmanager class=md-nav__link> AlarmManager </a> </li> <li class=md-nav__item> <a href=#downloadmanager class=md-nav__link> DownloadManager </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=procesy-a-vlakna-multithreding>Procesy a vlákna <small>(multithreding)</small><a class=headerlink href=#procesy-a-vlakna-multithreding title="Permanent link">&para;</a></h1> <p><a href=https://developer.android.com/guide/components/processes-and-threads>Android develoment <img src=images/small_link.png></a></p> <p>Pri spustení aplikácie Android OS spustí nový proces (Linux) s jedným vláknom. Štandardne všetky komponenty aplikácie bežia na rovnakom procese v tzv. "hlavnom" vlákne v Android-e tiež nazývané UI vlákno. Toto štandardné správanie sa dá ovplyvniť v manifeste <code>AndroidManifest.xml</code> a takisto v každom procese je možné vytvoriť ďalšie vlákna. </p> <h2 id=procesy>Procesy<a class=headerlink href=#procesy title="Permanent link">&para;</a></h2> <p>V predvolenom nastavení sú všetky komponenty tej istej aplikácie spustené v rovnakom procese a väčšina aplikácií by to nemala meniť. Ak však je potrebné zmeniť zaradenie do ktorého procesu daná komponenta patrí, môžeme tak spraviť v súbore <code>AndroidManifest.xml</code>:</p> <ul> <li>Komponenty ako<code>&lt;activity&gt;, &lt;service&gt;, &lt;receiver&gt;, &lt;provider&gt;</code> podporujú atribút <code>android:process</code>, pomocou ktorého môžeme upraviť v akom procese majú komponenty bežať (vlastný proces, zdielaný proces). </li> <li>Komponent <code>&lt;application&gt;</code> umožňuje nastaviť atribút <code>android:process</code>, ktorým sa nastaví predvolená hodnota. </li> </ul> <p>V prípadoch kedy Android potrebuje uvolniť HW prostriedky alebo šetriť energiou sa môže rozhodnúť nečinné procesy zastaviť. Ak niektoré zastavané komponenty majú opätovne pridelenú prácu tak sú znova spustené v procese.</p> <p>Pre správne fungovanie aplikácie je potrebné správne implementovať životný cyklus procesu (predchádzajúce prednášky a cvičenia). </p> <h2 id=vlakna>Vlákna<a class=headerlink href=#vlakna title="Permanent link">&para;</a></h2> <p>Pri spustení aplikácie systém vytvorí pre aplikáciu vlákno, ktoré sa nazýva hlavné vlákno alebo niekedy tiež "UI" vlákno. Toto vlákno je dôležité, pretože má na starosti odosielanie udalostí na príslušné komponenty užívateľského rozhrania. Dané vlákno je zodpovedné aj za samotné vykresľovanie UI. Za zvláštnych okolností však hlavné vlákno aplikácie nemusí byť totožné s UI vláknom. Ako je však uvedené v dokumentácii, rozdiel je dôležitý iba v súvislosti s niektorými systémovými aplikáciami (aplikáciami, ktoré sú spustené ako súčasť OS). Ďalšie informácie sa nachádzajú v téme <a href=https://developer.android.com/studio/write/annotations#thread-annotations>Annotations Thread</a>.</p> <h3 id=hlavne-ui-vlakno>Hlavné "UI" vlákno<a class=headerlink href=#hlavne-ui-vlakno title="Permanent link">&para;</a></h3> <p>Hlavné vlákno má jednoduchý dizajn: Jeho jedinou úlohou je čakať na pridelenie úlohy z pracovnej fronty a následne jej vykonanie. Tieto úlohy prichádzajú z rôznych zdrojov ako napr. udalosti späté zo životným cyklom aplikácie, udalosti od užívateľského rozhrania, udalosti od ostatných aplikácií. Pridelená úloha sa spracováva v rôznych obslužných metódach ako napr.:</p> <ul> <li> <p>v obslužných metódach životného cyklu <code>onStart(),onResume(),onRestart(), onCreate(),onPause(),onStop(), onDestroy()</code>, atď </p> </li> <li> <p>v obslužných metódach užívateľského rozhrania <code>onClick(), onKeyDown()</code>, atď</p> <blockquote> <p>Ukážka činnosti hlavného vlákna <img alt=img src=diagrams/out/threads.svg#center></p> </blockquote> </li> </ul> <p>Hlavné vlákno má tiež za úlohu v pravidelných intervaloch vykresľovať užívateľské rozhranie (každých 16ms čo je 60Hz). Ak hlavné vlákno vykonáva nejakú časovo náročnú úlohou alebo je zahltené veľkým množstvom udalostí na spracovanie tak užívateľské rozhranie môže byť spomalené. Ak hlavné vlákno sa zablokuje približne na päť sekúnd, systém zobrazí dialógové okno: <a href=https://developer.android.com/training/articles/perf-anr><em>aplikáciu neodpovedá</em></a> (ANR), ktoré umožňuje používateľovi zatvoriť aplikáciu.</p> <blockquote> <p>Normálna činnosť hlavného vlákna <img alt src=images/render_UI.png#center></p> </blockquote> <hr> <blockquote> <p>Zablokovanie hlavného vlákna <img alt src=images/render_UI_zablokovanie.png#center></p> </blockquote> <hr> <blockquote> <p>Presunutie náročenej operácie na pracovné vlákno <img alt src=images/render_UI_prav_vlakno.png></p> </blockquote> <hr> <blockquote> <p>Ak hlavné vlákno sa zablokuje približne na päť sekúnd, systém zobrazí dialógové okno <img alt=img src=images/anr.png#75size#center></p> </blockquote> <p>Najväčším dôvodom na zavádzanie vlákien do aplikácie je presun výpočtovo náročných úloh z hlavného vlákna preto, aby neovplyvňovali plynulosť vykresľovania a rýchlosť reakcie na vstup používateľa. Vlákna, ktoré odbremeňujú hlavné vlákno, budeme nazývať <em>pracovnými vláknami</em>. </p> <p>Prístup k metódam užívateľského rozhrania nie je s pohľadu viacvláknovej aplikácie bezpečný a teda priamy prístup k týmto metóda z iného vlákna ako je hlavné vlákno je zakázaný. </p> <div class="admonition note"> <p class=admonition-title>StrictMode – nástroj na detekciu omylov v kóde, ktoré môžu spôsobovať ANR hlášky <a href=https://developer.android.com/reference/android/os/StrictMode><img src=images/small_link.png></a></p> <p>StrictMode je nástroj pre vývojárov, ktorý má za úlohu upozorňovať na chyby z nepozornosti aby ste ich mohli opraviť.</p> <p>StrictMode sa najčastejšie používa na odhalenie náhodného prístupu na disk alebo do siete v hlavnom vlákne aplikácie, kde sa štandardne vykonávajú iba operácie týkajúce sa užvatelské rozhrania. Udržiavanie diskových a sieťových operácií mimo hlavného vlákna má pozitívny vplyv na plynulosť a rýchlu odozvu aplikácie.<br> <div class=highlight><pre><span></span><code><span class=kd>public</span> <span class=kt>void</span> <span class=nf>onCreate</span> <span class=p>()</span> <span class=p>{</span> 
     <span class=k>if</span> <span class=p>(</span><span class=n>DEVELOPER_MODE</span><span class=p>)</span> <span class=p>{</span> 
         <span class=n>StrictMode</span><span class=p>.</span><span class=na>setThreadPolicy</span> <span class=p>(</span><span class=k>new</span> <span class=n>ThreadPolicy</span><span class=p>.</span><span class=na>Builder</span><span class=p>()</span> 
                 <span class=p>.</span><span class=na>detectDiskReads</span> <span class=p>()</span> 
                 <span class=p>.</span><span class=na>detectDiskWrites</span> <span class=p>()</span> 
                 <span class=p>.</span><span class=na>detectNetwork</span> <span class=p>()</span> <span class=c1>// or .detectAll () pre všetky zistiteľné problémy </span>
                 <span class=p>.</span><span class=na>penaltyLog</span> <span class=p>()</span> 
                 <span class=p>.</span><span class=na>build</span> <span class=p>()</span> <span class=p>;</span> 
         <span class=n>StrictMode</span><span class=p>.</span><span class=na>setVmPolicy</span> <span class=p>(</span><span class=k>new</span> <span class=n>VmPolicy</span><span class=p>.</span><span class=na>Builder</span><span class=p>()</span> 
                 <span class=p>.</span><span class=na>detectLeakedSqlLiteObjects</span> <span class=p>()</span> 
                 <span class=p>.</span><span class=na>detectLeakedClosableObjects</span> <span class=p>()</span> 
                 <span class=p>.</span><span class=na>penaltyLog</span> <span class=p>()</span> 
                 <span class=p>.</span><span class=na>penaltyDeath</span> <span class=p>()</span> 
                 <span class=p>.</span><span class=na>build</span> <span class=p>());</span> 
     <span class=p>}</span> 
     <span class=kd>super</span><span class=p>.</span><span class=na>onCreate</span> <span class=p>();</span> 
 <span class=p>}</span>
</code></pre></div></p> </div> <div class="admonition note"> <p class=admonition-title>Vylepšite kontrolu kódu pomocou anotácií <a href=https://developer.android.com/studio/write/annotations#thread-annotations><img src=images/small_link.png></a></p> <p>Android podporuje množstvo anotácií prostredníctvom <a href=https://developer.android.com/topic/libraries/support-library/features#annotations>Knižnice podpory anotácií</a> . Knižnicu môžete získať prostredníctvom <code>android.support.annotation</code> balíka.<br> Ak chcete do svojho projektu pridať knižnicu na podporu anotácií, do <code>dependencies</code> bloku v súbore <code>build.gradle</code> pridajte nasledujúci riadok a zosynchronizujte projekt: <div class=highlight><pre><span></span><code><span class=n>dependencies</span> <span class=o>{</span>
    <span class=n>implementation</span> <span class=s1>&#39;com.android.support:support-annotations:28.0.0&#39;</span>
<span class=o>}</span>
</code></pre></div> Ak chcete spustiť kontrolu kódu z Android Studia, ktorá zahŕňa overenie anotácií a automatickú kontrolu pomocou programu Lint, na paneli s ponukami vyberte <strong>Analyzovať</strong> &gt; <strong>Skontrolovať kód</strong> ( <strong>Analyze</strong> &gt; <strong>Inspect Code</strong>).</p> <div class="admonition warning"> <p class=admonition-title>Upozorňujeme, že hoci konflikty anotácií generujú upozornenia, tieto upozornenia nebránia kompilácii aplikácie.</p> </div> <p><strong>Najčastejšie používané anotácie anotácii:</strong></p> <ul> <li>Kotrola null hodnôt:<ul> <li><a href=https://developer.android.com/reference/androidx/annotation/Nullable>@Nullable</a> <a href=https://developer.android.com/reference/androidx/annotation/NonNull>@NonNull</a></li> </ul> </li> <li>Anotácie zdrojov:<ul> <li>napr. <a href=https://developer.android.com/studio/write/annotations#res-annotations>@DrawableRes, @DimenRes, @ColorResa @InterpolatorRes, @StringRes</a></li> </ul> </li> <li>Anotácie na obmedzenie vstupných hodnôt<ul> <li>napr. <a href=https://developer.android.com/studio/write/annotations#value-constraint>@IntRange, @FloatRangea, @Size</a></li> </ul> </li> <li>Anotácie k povoleniam<ul> <li>napr. <a href=https://developer.android.com/studio/write/annotations#permissions>@RequiresPermission</a></li> </ul> </li> <li><strong>Anotácie na kontrolu, či sa metóda volá z konkrétneho typu vlákna</strong><ul> <li><a href=https://developer.android.com/reference/androidx/annotation/MainThread>@MainThread</a></li> <li><a href=https://developer.android.com/reference/androidx/annotation/UiThread>@UiThread</a></li> <li><a href=https://developer.android.com/reference/androidx/annotation/WorkerThread>@WorkerThread</a></li> <li><a href=https://developer.android.com/reference/androidx/annotation/BinderThread>@BinderThread</a></li> <li><a href=https://developer.android.com/reference/androidx/annotation/AnyThread>@AnyThread</a> </li> </ul> </li> <li>Ostatné si možete dohladať <a href=https://developer.android.com/studio/write/annotations>tu<img src=images/small_link.png></a> </li> </ul> </div> <p>Ako už bolo písané v predchádzajúcich odsekoch na hlavnom vlákne sa nesmú vykonávať časovo náročné úlohy, ktoré by mohli toto vlákno zablokovať. Všetky náročnejšie úlohy by sa mali vykonávať na pracovných vláknach, ktoré sú riadené z hlavného vlákna. Treba pripomenúť, že práca z užívateľským rozhraním je dovolená iba z hlavného vlákna. </p> <p>Na vyriešenie problému s prístupom k užívateľskému rozhranie mimo hlavného vlákna Android poskytuje viacero možností: </p> <ul> <li> <p><a href=https://developer.android.com/reference/android/app/Activity#runOnUiThread(java.lang.Runnable)><code>Activity.runOnUiThread(Runnable)</code></a></p> </li> <li> <p><a href=https://developer.android.com/reference/android/view/View#post(java.lang.Runnable)><code>View.post(Runnable)</code></a></p> </li> <li> <p><a href=https://developer.android.com/reference/android/view/View#postDelayed(java.lang.Runnable,%20long)><code>View.postDelayed(Runnable, long)</code></a></p> </li> </ul> <blockquote> <p>Príklad aktualizácie užávateľského rozhrania z pracovného vlákna pomocu odoslania <code>Runnable</code> objektu <div class=highlight><pre><span></span><code><span class=kd>public</span> <span class=kt>void</span> <span class=nf>onClick</span><span class=p>(</span><span class=n>View</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>new</span> <span class=n>Thread</span><span class=p>(</span><span class=k>new</span> <span class=n>Runnable</span><span class=p>()</span> <span class=p>{</span>
        <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=p>()</span> <span class=p>{</span>
            <span class=c1>// potenciálne časovo náročná úloha</span>
            <span class=kd>final</span> <span class=n>Bitmap</span> <span class=n>bitmap</span> <span class=o>=</span>
                    <span class=n>processBitMap</span><span class=p>(</span><span class=s>&quot;image.png&quot;</span><span class=p>);</span>
            <span class=n>imageView</span><span class=p>.</span><span class=na>post</span><span class=p>(</span><span class=k>new</span> <span class=n>Runnable</span><span class=p>()</span> <span class=p>{</span>
                <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=p>()</span> <span class=p>{</span>
                    <span class=n>imageView</span><span class=p>.</span><span class=na>setImageBitmap</span><span class=p>(</span><span class=n>bitmap</span><span class=p>);</span>
                <span class=p>}</span>
            <span class=p>});</span>
        <span class=p>}</span>
    <span class=p>}).</span><span class=na>start</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div> Operácia úpravy obrázku sa vykonáva zo samostatného vlákna, zatiaľ čo s objektom <code>ImageView</code>sa vždy manipuluje z hlavného vlákna (UI). ```</p> </blockquote> <p>Z rastúcou zložitosťou aplikácie môže priame používanie vláken byť kompilované a neprehľadné. Android poskytuje efektívnejšie spôsoby ako pracovať s úlohami na pozadí: </p> <ul> <li>Vykonanie náročných výpočtov na pozadí za pomoci <code>service</code> komponenty systému a využitia notifikácii (<code>notifications</code>) pre informovanie používateľa. <ul> <li><code>IntentService, Foreground service</code></li> </ul> </li> <li>Vykonanie náročných výpočtov pomocou <em>vlákna</em>. Spolupráca a komunikácia medzi vláknami je možná pomocou obslužných <em>Handler</em> objektov a posielania <em>Runnable</em> objektov.<ul> <li><code>AsyncTask, AsyncTaskLoader, HandlerThread, ThreadPool</code></li> </ul> </li> <li>Špecializované knižnice <ul> <li><code>WorkManager, AlarmManager, DownloadManager</code></li> </ul> </li> </ul> <h3 id=nastavenie-priority>Nastavenie priority<a class=headerlink href=#nastavenie-priority title="Permanent link">&para;</a></h3> <p>Priorita, ktorú dostanú vlákna v aplikácií, závisí čiastočne od toho, kde sa aplikácia nachádza v životnom cykle aplikácie. Pri vytváraní a správe vlákien je dôležité nastaviť ich prioritu. Ak je nastavená príliš vysoko, vaše vlákno môže prerušiť vlákno UI a RenderThread, čo môže spôsobiť, že aplikácia vynechá rámce pri vykresľovaní UI. Opačný extrém je ak je nastavená príliš nízka priorita, čo môže spôsobiť, že asynchrónne úlohy (napríklad načítanie obrázkov) budú príliš spomalené. </p> <p>Vždy, keď je vytvorené nové vlákno je vhodné zavolať <code>setThreadPriority()</code> a nastaviť vláknu vhodnú prioritu tak aby plánovač vybalancoval vytaženie CPU. Pre jednoduchšie zvolenie správnej priority existujú pomocné konštanty cez ktoré môžete zvoliť správnu prioritu viď. tabuľka nižšie. Napríklad <code>THREAD_PRIORITY_DEFAULT</code> predstavuje predvolenú hodnotu pre vlákno. Aplikácia by mala nastaviť prioritu <code>THREAD_PRIORITY_BACKGROUND</code> pre vlákna, ktoré vykonávajú menej naliehavú prácu.</p> <p>Vlákna, ktoré sú v aplikácii, ktorá je v <a href="https://www.youtube.com/watch?v=NwFXVsM15Co&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&index=9">popredí zvyčajne získavajú asi 95% procesného času</a>, zatiaľ čo vlákna v aplikácii v pozadí získavajú iba zhruba 5%.</p> <p>V predvolenom nastavení systém nastaví prioritu vlákna na rovnakú prioritu a členstvo v skupine ako vlákno, ktoré vytvorilo nové vlákno.</p> <table> <thead> <tr> <th></th> <th>Konštanta</th> </tr> </thead> <tbody> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_AUDIO</code>Standard priority of audio threads.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_BACKGROUND</code>Standard priority background threads.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_DEFAULT</code>Standard priority of application threads.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_DISPLAY</code>Standard priority of system display threads, involved in updating the user interface.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_FOREGROUND</code>Standard priority of threads that are currently running a user interface that the user is interacting with.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_LESS_FAVORABLE</code>Minimum increment to make a priority less favorable.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_LOWEST</code>Lowest available thread priority.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_MORE_FAVORABLE</code>Minimum increment to make a priority more favorable.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_URGENT_AUDIO</code>Standard priority of the most important audio threads.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_URGENT_DISPLAY</code>Standard priority of the most important display threads, for compositing the screen and retrieving input events.</td> </tr> <tr> <td><code>int</code></td> <td><code>THREAD_PRIORITY_VIDEO</code>Standard priority of video threads.</td> </tr> </tbody> </table> <p>Viac informácií o správe vlákien nájdete v referenčnej dokumentácii o triedach <code>Thread</code>a <code>Process</code><a href=https://developer.android.com/guide/topics/processes/process-lifecycle><img src=images/small_link.png></a>.</p> <h3 id=pomocne-triedy-pre-pracu-z-vlaknami>Pomocné triedy pre prácu z vláknami<a class=headerlink href=#pomocne-triedy-pre-pracu-z-vlaknami title="Permanent link">&para;</a></h3> <h4 id=asynctask>AsyncTask <a href=https://developer.android.com/reference/android/os/AsyncTask><img src=images/small_link.png></a><a class=headerlink href=#asynctask title="Permanent link">&para;</a></h4> <p>AsyncTask trieda je jednoduchá a užitočná pomôcka pre aplikácie, ktoré potrebujú rýchlo presunúť prácu z hlavného vlákna na pracovné vlákna. Napríklad ak nejaká vstupná udalosť vyvolá akciu kde je treba načítať obrázok a následne aktualizovať používateľské rozhranie . Použitím AsyncTask triedy sa jednoduchým spôsobom môže presunúť bremeno sťahovania a dekódovania obrázku na pomocné pracovné vlákno a následne AsyncTask trieda zabezpečí odovzdanie výsledku hlavnému vláknu, ktoré môže pristupovať k užívateľskému rozhraniu.</p> <p>Pri používaní AsyncTask je potrebné pamätať na niekoľko dôležitých aspektov: </p> <ul> <li>V predvolenom nastavení všetky vytvorené AsyncTask objekty zdieľajú jedno spoločné vlákno. Preto ak je v jednom momente spustených viacej AsyncTask-ov v skutočnosti sa spúšťajú sériovo. Pri tejto štandardnej konfigurácie platí odporúčanie, aby jednotlivé AsyncTask úlohy vedeli svoju činnosť dokončiť do 5 ms a tým neblokovali príliš dlho spoločné vlákno. <ul> <li>V prípade, že potrebujete vykonanie viacero AsyncTaskov paralelne môžete tak docieliť nastavením iného executora: <code>executeOnExecutor (java.util.concurrent.Executor, Object []) s THREAD_POOL_EXECUTOR.</code> </li> </ul> </li> <li>AsyncTask úlohy sú tiež najčastejšími páchateľmi problémov s <a href=https://developer.android.com/topic/performance/threads#implicit>implicitnými referenciami</a>.</li> <li>AsyncTask úlohy tiež predstavujú riziká spojené s explicitnými referenciami, ale v niektorých prípadoch je ich možné ľahko vyriešiť. Napríklad AsyncTask môže držať referenciu na objekt užívateľského rozhrania(typ <code>View</code>), táto referencia sa používa na aktualizáciu užívateľského rozhrania. Akonáhle AsyncTask dokončí svoju prácu odovzdá referenciu tohoto objekt hlavnému vláknu, kde sa použije na aktualizáciu užívateľského rozhrania. V takejto situácii môže dochádzať k memory leak-u, kedy udržiavaná referencia bude ukazovať na objekt, ktorý už nie je používaný. Na vyriešenie tohoto problému môžeme použiť <code>WeakReference</code> na uloženie referencie na požadovaný objekt používateľského rozhrania a na prístup k objektu.</li> </ul> <p>AsyncTask je definovaná týmito prvkami:</p> <table> <thead> <tr> <th><strong>3 generické typy</strong></th> <th><strong>4 základné stavy</strong></th> <th><strong>1 pomocná metóda</strong></th> </tr> </thead> <tbody> <tr> <td>Vstupné parametre, Progres, Výsledok</td> <td><code>onPreExecute, doInBackground, onProgressUpdate,onPostExecute</code></td> <td><code>publishProgress</code></td> </tr> </tbody> </table> <table> <thead> <tr> <th align=left><strong>Popis</strong></th> <th><strong>Vlákno na ktorom sa vykonáva kód</strong></th> </tr> </thead> <tbody> <tr> <td align=left><code>onPreExecute()</code> spustené na UI vlákne okamžite po spustení úlohy. Táto metóda sa používa na prípravu úlohy, ako napríklad pripravenie užívateľského rozhrania(napr. zobrazenie progres-baru na používateľskom rozhraní).</td> <td>hlavné "UI" vlákno</td> </tr> <tr> <td align=left><code>doInBackground(Params...)</code> spustené na vlákne pracujúcom v pozadí hneď po <code>onPreExecute()</code> skončí svoju činnosť. V tejto metóde sa vykonáva práca, ktorá má bežať na pozadí. V tejto metóde môžeme volať <code>publishProgress(Progress...)</code>, pomocou ktorej sa publikujú priebežné výsledky.</td> <td>pracovné vlákno</td> </tr> <tr> <td align=left><code>onProgressUpdate(Progress...)</code> spustené na UI vlákne po zavolaní <code>publishProgress(Progress...)</code> metódy. Čas vykonania nie je definovaný. Táto metóda slúži na zobrazenie hocijakej formy progresu v užívateľskom rozhraní.</td> <td>hlavné "UI" vlákno</td> </tr> <tr> <td align=left><code>onPostExecute(Result)</code> spustené na UI vlákne po ukončení úlohy na pozadí.</td> <td>hlavné "UI" vlákno</td> </tr> </tbody> </table> <blockquote> <p>Ukážka interakcie hlavného vlákna s AsyncTask vláknom <img alt=img src=diagrams/out/asynctasl.svg#center></p> </blockquote> <hr> <blockquote> <p>Príklad použitia: <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kd>class</span> <span class=nc>VerySlowTask</span> <span class=kd>extends</span> <span class=n>AsyncTask</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span> <span class=n>Long</span><span class=p>,</span> <span class=n>Void</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=c1>// Begin - can use UI thread here</span>
    <span class=kd>protected</span> <span class=kt>void</span> <span class=nf>onPreExecute</span><span class=p>()</span> <span class=p>{</span>
    <span class=p>}</span>
    <span class=c1>// this is the SLOW background thread taking care of heavy tasks</span>
    <span class=c1>// cannot directly change UI</span>
    <span class=kd>protected</span> <span class=n>Void</span> <span class=nf>doInBackground</span><span class=p>(</span><span class=kd>final</span> <span class=n>String</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span> <span class=n>publishProgress</span><span class=p>((</span><span class=n>Long</span><span class=p>)</span> <span class=n>someLongValue</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=c1>// periodic updates - it is OK to change UI</span>
    <span class=nd>@Override</span>
    <span class=kd>protected</span> <span class=kt>void</span> <span class=nf>onProgressUpdate</span><span class=p>(</span><span class=n>Long</span><span class=p>...</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>}</span>
    <span class=c1>// End - can use UI thread here</span>
    <span class=kd>protected</span> <span class=kt>void</span> <span class=nf>onPostExecute</span><span class=p>(</span><span class=kd>final</span> <span class=n>Void</span> <span class=n>unused</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> </blockquote> <p><strong>Zrušenie úlohy</strong></p> <p>Zrušiť úlohu môžete v ľubovoľnom čase zavolaním metódy <code>cancel(boolean)</code>. Po zavolaní metódy <code>cancel()</code> sa vyvolá funkcia <code>onCancelled(Object)</code>, až po ukončení práce vo funkcii <code>doInBackground(Object[])</code>. Pre urýchlenie ukončenia úlohy treba vo funkcii <code>doInBackground(Object[])</code> periodicky kontrolovať návratovú hodnotu z <code>isCancelled()</code>.</p> <div class="admonition warning"> <p class=admonition-title>Od verzie API level R je AsyncTask trieda označená ako deprecated</p> </div> <h4 id=handlerthread>HandlerThread<a class=headerlink href=#handlerthread title="Permanent link">&para;</a></h4> <p>Aj keď AsyncTask je užitočný, nemusí byť vždy tým správnym riešením problému pre prácu s vláknami. V niektorých prípadoch je potrebné alebo vhodnejšie použiť tradičnejší prístup, v ktorom existuje pracovné vlákno, ktoré ma dlhú životnosť a tomuto vláknu sú prideľované pracovné bloky, ktoré sú na ňom vykonávané. </p> <p>Uvažujme o prípade kedy získavame snímky z kamery pomocou <code>Camera</code> objektu. Po zaregistrovaní požiadavky na príjem snímok s náhľadom kamery, dostávame ich v <code>onPreviewFrame()</code> spätnom volaní, ktoré sa vyvolá na vlákne, z ktorého bolo zaregistrované. Ak by sa toto spätné volanie vyvolalo na hlavnom vlákne "UI" , náročná úloha spracovania obrázkov by potencionálne mohla narušiť plynulé vykresľovanie a spracovaním udalostí. Rovnaký problém sa týka aj tých AsyncTask-ov, ktoré tiež svoje úlohy vykonávajú sériovo a môžu v prípravnej fáze(<code>onPreExecute()</code> spustené na hlavnom vlákne) zablokovať hlavné vlákno, ktoré ich vytvára.</p> <p>Toto je situácia, keď by bolo vhodné použiť <code>HandlerThread</code>: vlákno obsluhy je efektívne dlhodobo prebiehajúce vlákno, ktoré odoberá pracovné bloky vo forme <code>Runnable</code> objektu zo zásobníka, ktorý je sním spätý. V tomto prípade, keď aplikácia deleguje <code>Camera.open()</code> príkaz na pracovné vlákno, tak v tomto priradené spätné volanie <code>onPreviewFrame()</code> bude vykonávané práve na tomto pracovnom vlákne, tým pádom UI vlákno je odbremenené. </p> <p>Keď aplikácia vytvorí vlákno pomocou <code>HandlerThread</code>, netreba zabúdať na nastavenie správnej priority vlákna na základe charakteru vykonávanej práce. </p> <div class="admonition note"> <p class=admonition-title>Poznámky na zváženie pri práci s HandlerThread</p> <ul> <li>HandlerThread-y bežia mimo životného cyklu aktivity, takže sa nesmie zabudnúť na ich správne ukončenie ak už niesu potrebné, inak môže dochádzať k nechcenému vytváraniu nových vlákien. Toto je obzvlášť nebezpečné, ak sa používajú pre dlhodobo prebiehajúce procesy. </li> <li>Neexistuje žiadny podobný mechanizmus na spätné odosielanie výsledkov do hlavného vlákna ako je tu v prípade AsyncTask-u. To znamená viac kódu, ktorý je potrebné písať.</li> </ul> </div> <h5 id=praca-s-handlerthread>Práca s HandlerThread<a class=headerlink href=#praca-s-handlerthread title="Permanent link">&para;</a></h5> <p>Pri práci s HandlerThread je potrebné vytvoriť a prepojiť zásobník správ a úloh, z ktorého si bude HandlerThread odoberať úlohy pre svoju činnosť. Táto fronta je tvorená objektom <code>Handler</code>.</p> <div class=highlight><pre><span></span><code><span class=n>HandlerThread</span> <span class=n>handlerThread</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HandlerThread</span> <span class=p>(</span><span class=s>&quot;MyHandlerThread&quot;</span><span class=p>);</span> 
<span class=n>handlerThread</span><span class=p>.</span><span class=na>start</span> <span class=p>();</span> 
<span class=n>Looper</span> <span class=n>looper</span> <span class=o>=</span> <span class=n>handlerThread</span><span class=p>.</span><span class=na>getLooper</span> <span class=p>();</span> 
<span class=n>Handler</span> <span class=n>handler</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Handler</span> <span class=p>(</span><span class=n>looper</span><span class=p>);</span>
</code></pre></div> <p>Ako prvé vytvoríme nový HandlerThread a pomenujeme ho. Potom spustíme HandlerThread, získame Looper pre HandlerThread a odovzdáme ho Handler-ovi</p> <h5 id=zasobnik-sprav-handler>Zásobník správ - Handler<a class=headerlink href=#zasobnik-sprav-handler title="Permanent link">&para;</a></h5> <p>Vlákno, ktoré chce komunikovať s hlavným vláknom alebo <code>HandlerThread</code> vláknom si musí vyžiadať token za pomoci metódy <code>obtainMessage()</code>. Po obdržaní tokenu môže vlákno naplniť dáta do token objektu a za pomoci metódy <code>sendMessage()</code> tento token zaradiť do zásobníka správ. Vytvorený <code>Handler</code> volá metódu <code>handleMessage()</code> po prijatí novej správy. Správa odobratá zo zásobníka správ obsahuje dáta alebo požiadavku na vykonanie <code>Runnable</code> objektu vložného pomocou metódu <code>post()</code>.</p> <blockquote> <p>Mechanizmus odovzdania <code>Runnable</code> objektu alebo správy. <code>Runnable</code> objekt predstavuje pracovný blok, ktorý sa má vykonať na vlákne príjemcu (pracovné vlákno alebo hlavné vlákno). <img alt=~~img~~ src=images/handler.png#center></p> </blockquote> <hr> <blockquote> <p><strong>Inicializácia vlákna a handlera v hlavnom vlákne</strong></p> <div class=highlight><pre><span></span><code><span class=c1>//Inicializácia handler vlákna </span>
<span class=kd>final</span> <span class=n>HandlerThread</span> <span class=n>backJob</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HandlerThread</span><span class=p>(</span><span class=s>&quot;Vlakno casovaca&quot;</span><span class=p>);</span>
<span class=n>backJob</span><span class=p>.</span><span class=na>start</span><span class=p>();</span> <span class=c1>//Spustenie vlákna</span>

<span class=c1>//Pridelenie looper slučky do Handler triedy</span>
<span class=n>Looper</span> <span class=n>mLooper</span> <span class=o>=</span> <span class=n>backJob</span><span class=p>.</span><span class=na>getLooper</span><span class=p>();</span>
<span class=n>mHandler</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MyHandler</span><span class=p>(</span><span class=n>mLooper</span><span class=p>);</span>
</code></pre></div> </blockquote> <hr> <blockquote> <p><strong>Vytvorenie triedy handlera</strong></p> <div class=highlight><pre><span></span><code><span class=c1>// Handler pre HandlerThread</span>
<span class=kd>class</span> <span class=nc>MyHandler</span> <span class=kd>extends</span> <span class=n>Handler</span> <span class=p>{</span>
  <span class=kd>public</span> <span class=nf>MyHandler</span><span class=p>(</span><span class=n>Looper</span> <span class=n>myLooper</span><span class=p>)</span> <span class=p>{</span>
      <span class=kd>super</span><span class=p>(</span><span class=n>myLooper</span><span class=p>);</span>
  <span class=p>}</span>   
  <span class=c1>//Obsluha prijatia správy </span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>handleMessage</span><span class=p>(</span><span class=n>Message</span> <span class=n>msg</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> </blockquote> <hr> <blockquote> <p><strong>Ukážka odosielania správy</strong></p> <div class=highlight><pre><span></span><code><span class=n>Message</span> <span class=n>msg</span> <span class=o>=</span> <span class=n>mHandler</span><span class=p>.</span><span class=na>obtainMessage</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=n>data</span><span class=p>);</span>
<span class=n>mHandler</span><span class=p>.</span><span class=na>sendMessage</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
</code></pre></div> </blockquote> <h4 id=threadpool>ThreadPool<a class=headerlink href=#threadpool title="Permanent link">&para;</a></h4> <p>V praxi existujú určité druhy práce, ktoré možno efektívne paralelizovať. Jednou z takýchto úloh je napríklad filtrácia obrázku po blokoch 8x8 s rozlíšením obrázku 8 megapixelov. Takýto druhu úlohy je v dnešných viacjadrových zariadenia vhodné paralelizovať s viacerými vláknami. Paralelizovať danú úlohu by predstavovala pre programátora úlohu manuálne balansovať záťaže vytvorených vlákien, tomuto sa ale chceme vyhnúť. </p> <p><code>ThreadPoolExecutor</code> je pomocná trieda na uľahčenie tohto procesu. Táto trieda riadi vytváranie skupiny vlákien, určuje ich priority a riadi rozdelenie práce medzi tieto vlákna. Keď sa pracovné zaťaženie zvyšuje, trieda <code>Executor</code> zväčšuje počet vlákien, v opačnom prípade, keď sa zaťaženie znižuje tak znižuje aj počet vlákien. Tak to sa deje vždy s prihliadnutím aby sa prispôsobil počet spustených vlákien aktuálnemu pracovnému zaťaženiu.</p> <p>Táto trieda tiež pomáha aplikácii vytvoriť optimálny počet vlákien. Pri vytváraní <code>ThreadPoolExecutor</code> objektu aplikácia nastaví minimálny a maximálny počet vlákien. Pretože pracovné zaťaženie je dané, trieda ThreadPoolExecutor vezme do úvahy definované hodnoty minimálneho a maximálneho počtu vlákien a zváži množstvo nevybavenej práce, ktorú treba vykonať. Na základe týchto faktorov ThreadPoolExecutor rozhoduje o tom, koľko vlákien by malo byť v danom okamihu nažive.</p> <h3 id=vlakna-a-zmeny-konfiguracierestart-aplikacie>Vlákna a zmeny konfigurácie(reštart aplikácie)<a class=headerlink href=#vlakna-a-zmeny-konfiguracierestart-aplikacie title="Permanent link">&para;</a></h3> <p>Pri reštarte aktivity z dôvodu zmeny konfigurácie (napr. otočenie displeja) treba mať na zreteli:</p> <ul> <li>aktivita, ktorá si vytvorila vlákno na spracovanie úloh na pozadí napr. <code>AsyncTask</code>, musí pri reštarte buď túto úlohu zrušiť alebo ošetriť aby dané vlákno o reštarte bolo informované.</li> <li>Vo vlákne bežiacom na pozadí treba rozvážne používať metódu getActivity(), ktorá môže počas reštartu aplikácie vrátiť inštanciu už neexistujúcej aktivity. </li> </ul> <h2 id=dlhotrvajuce-ulohy-na-pozadi>Dlhotrvajúce úlohy na pozadí <a href=https://developer.android.com/guide/background/ ><img src=images/small_link.png></a><a class=headerlink href=#dlhotrvajuce-ulohy-na-pozadi title="Permanent link">&para;</a></h2> <p>V predchádzajúci časti sme sa venovali vláknam, ktoré slúžia na odbremenenia hlavného vlákna od práce, ktorá môže dané vlákno vyťažiť a spôsobiť tzv. zmrznutie aplikácie. Práca, ktorá sa vykonáva na pracovných vláknach ma charakter krátkodobej úlohy, ktorá je priamo spätá s aplikáciu bežiacou na popredí s ktorou užívateľ aktívne pracuje. </p> <p>Aplikácie môžu vyžadovať spustenie niektorých úloh, aj keď používateľ aplikáciu aktívne nepoužíva, napríklad pravidelnú synchronizáciu so serverom alebo pravidelné načítavanie nového obsahu v aplikácii. Aplikácie môžu tiež vyžadovať, aby sa služby spustili okamžite po dokončení úlohy, aj keď používateľ prestal aktívne aplikáciou používať. Táto kapitola má zacieľ napomôcť zistiť, ktoré riešenie najlepšie vyhovuje vašim potrebám v týchto prípadoch použitia.</p> <h4 id=obmedzenia-android-os-ktore-ovplyvnuju-vykonavanie-uloh-na-pozadi>Obmedzenia Android OS, ktoré ovplyvňujú vykonávanie úloh na pozadí<a class=headerlink href=#obmedzenia-android-os-ktore-ovplyvnuju-vykonavanie-uloh-na-pozadi title="Permanent link">&para;</a></h4> <p>Aby sa maximalizovala výdrž batérie a vynútilo sa dobré správanie aplikácie, Android obmedzuje prácu na pozadí, keď používateľ aktívne nevyužíva aplikáciu (notifikácia na službu).</p> <ul> <li> <p>Android 6.0 (API úroveň 23) predstavil <a href=https://developer.android.com/training/monitoring-device-state/doze-standby>režim Doze a pohotovostný režim aplikácie</a> . Režim Doze obmedzuje správanie aplikácie, keď je obrazovka vypnutá a zariadenie je nehybné (leží na stole bez pohnutia). Pohotovostný režim stavia nepoužívané aplikácie do špeciálneho stavu, ktorý obmedzuje ich prístup k sieti, úlohy a synchronizáciu.</p> </li> <li> <p>Android 7.0 (API úroveň 24) obmedzoval implicitné vysielanie a predstavil <a href=https://developer.android.com/about/versions/nougat/android-7.0#doze_on_the_go>Doze-on-the-Go</a> .</p> </li> <li> <p>Android 8.0 (API úroveň 26) ďalej <a href=https://developer.android.com/about/versions/oreo/background>obmedzoval chovanie na pozadí</a> , napríklad získavanie polohy na pozadí a uvoľňovanie <a href=https://developer.android.com/training/scheduling/wakelock>wakelokov</a> z pamäti.</p> </li> <li> <p>Android 9 (API úroveň 28) predstavil <a href=https://developer.android.com/topic/performance/appstandby>segmenty pohotovostného režimu pre aplikácie</a> , v ktorých sú žiadosti o prostriedky na zdroje dynamicky uprednostňované na základe vzorov používania aplikácií.</p> </li> </ul> <p><img alt src=diagrams/out/bgProcessing.svg></p> <h3 id=workmanager>WorkManager <a href=https://developer.android.com/topic/libraries/architecture/workmanager><img src=images/small_link.png></a><a class=headerlink href=#workmanager title="Permanent link">&para;</a></h3> <p>Určené pre:</p> <ul> <li>nezávislá úloha s predpokladom, že má bežať aj keď aplikácia alebo zariadenia sa reštartuje</li> <li>spustenie úlohy pri splnení systémových požiadaviek(napr. dostupná sieť, batéria je nabitá)</li> <li>súčasť AndroidX spätná kompatibilita až na API level 14</li> <li>WorkManager tiež podporuje spúšťanie úloh ako službu v popredí(Foreground service), čo je ideálne, keď úloha by nemala byť prerušená. </li> </ul> <h3 id=foreground-services-sluzba-v-popredi>Foreground services / Služba v popredí <a href=https://developer.android.com/guide/components/services><img src=images/small_link.png></a><a class=headerlink href=#foreground-services-sluzba-v-popredi title="Permanent link">&para;</a></h3> <ul> <li>Pre prácu iniciovanú používateľom, ktorá musí byť spustená okamžite a musí byť vykonaná až do ukončenia.</li> <li>Používanie služby foreground service povie systému, že aplikácia robí niečo dôležité a nemala by byť zabitá. </li> <li>Služby popredia sú pre používateľov viditeľné prostredníctvom oznámenia(notofication), ktoré sa nedá zrušiť</li> </ul> <h3 id=alarmmanager>AlarmManager <a href=https://developer.android.com/reference/android/app/AlarmManager><img src=images/small_link.png></a><a class=headerlink href=#alarmmanager title="Permanent link">&para;</a></h3> <p>Ak potrebujete spustiť úlohu v presnom čase, použite AlarmManager. AlarmManager v prípade potreby spustí vašu aplikáciu na vykonanie úlohy v čase, ktorý určíte. Ak však vaša práca nemusí prebiehať v presnom čase, WorkManager je lepšou možnosťou. WorkManager dokáže lepšie vyvážiť systémové prostriedky. Napríklad, ak potrebujete spustiť úlohu každú hodinu, ale nie potrebné úplne presné načasovanie, mali by ste použiť WorkManagerna a nastaviť opakujúcu sa úlohu.</p> <h3 id=downloadmanager>DownloadManager <a href=https://developer.android.com/reference/android/app/DownloadManager><img src=images/small_link.png></a><a class=headerlink href=#downloadmanager title="Permanent link">&para;</a></h3> <ul> <li>stiahnutie veľkých súborov alebo veľa súborov cez HTTP, zvážte použitie DownloadManager</li> <li>stiahnutie vykoná na pozadí, pričom sa postará o interakcie s HTTP</li> <li>opakované stiahnutie pri zlyhaniach alebo pri zmenách pripojenia a reštartovaní systému</li> </ul> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=senzory/ title=Senzory class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Next </span> Senzory </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d=M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z /></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <script src=assets/javascripts/vendor.36cbf620.min.js></script> <script src=assets/javascripts/bundle.00c583dd.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script> <script>
        app = initialize({
          base: ".",
          features: ["tabs", "instant"],
          search: Object.assign({
            worker: "assets/javascripts/worker/search.7f7c8775.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>